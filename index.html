<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toolboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%20300%20300%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%20%20%3Crect%20width%3D%22290%22%20height%3D%22290%22%20fill%3D%22%23444%22%20rx%3D%2210%22%20ry%3D%2210%22%20%2F%3E%20%20%3Cdefs%3E%20%20%20%20%3Cpattern%20id%3D%22peg-grid%22%20x%3D%2215%22%20y%3D%2215%22%20width%3D%2230%22%20height%3D%2230%22%20patternUnits%3D%22userSpaceOnUse%22%3E%20%20%20%20%20%20%3Ccircle%20cx%3D%2210%22%20cy%3D%2210%22%20r%3D%2210.5%22%20fill%3D%22%23000%22%20%2F%3E%20%20%20%20%3C%2Fpattern%3E%20%20%3C%2Fdefs%3E%20%20%3Crect%20x%3D%225%22%20y%3D%225%22%20width%3D%22275%22%20height%3D%22275%22%20fill%3D%22url(%23peg-grid)%22%20%2F%3E%20%20%3Cg%20fill%3D%22%23ff8%22%3E%20%20%20%20%3Ccircle%20cx%3D%2225%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2225%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2225%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2255%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2255%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2255%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2285%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2285%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2285%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22205%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22205%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22205%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22235%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22235%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22235%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22265%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22265%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22265%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22115%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22115%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22115%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22145%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22145%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22145%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22175%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22175%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22175%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22205%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22205%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22205%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22235%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22235%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22235%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22265%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22265%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22265%22%20r%3D%2210.5%22%20%2F%3E%20%20%3C%2Fg%3E%3C%2Fsvg%3E">
    <style>
:root {
    --bg-primary: #f5f5f5;
    --bg-secondary: white;
    --bg-tertiary: #f8f9fa;
    --bg-header: #2c3e50;
    --bg-note-header: #34495e;
    --text-primary: #333;
    --text-secondary: #666;
    --text-muted: #7f8c8d;
    --text-heading: #2c3e50;
    --border-color: #ddd;
    --border-light: #eee;
    --shadow-light: rgba(0,0,0,0.1);
    --shadow-medium: rgba(0,0,0,0.15);
    --shadow-heavy: rgba(0,0,0,0.25);
    --overlay-bg: rgba(0,0,0,0.5);
    --code-bg: #f4f4f4;
    --table-stripe: #f8f9fa;
    --table-hover: #e8f4fd;
    --input-bg: white;
    --success-bg: #d4edda;
    --success-text: #155724;
    --error-bg: #f8d7da;
    --error-text: #721c24;
}

body.dark-mode {
    --bg-primary: #1a1a2e;
    --bg-secondary: #16213e;
    --bg-tertiary: #1f2940;
    --bg-header: #0f0f23;
    --bg-note-header: #1f2940;
    --text-primary: #e4e4e7;
    --text-secondary: #a1a1aa;
    --text-muted: #71717a;
    --text-heading: #e4e4e7;
    --border-color: #3f3f46;
    --border-light: #27272a;
    --shadow-light: rgba(0,0,0,0.3);
    --shadow-medium: rgba(0,0,0,0.4);
    --shadow-heavy: rgba(0,0,0,0.5);
    --overlay-bg: rgba(0,0,0,0.7);
    --code-bg: #27272a;
    --table-stripe: #1f2940;
    --table-hover: #2d3a52;
    --input-bg: #1f2940;
    --success-bg: #064e3b;
    --success-text: #6ee7b7;
    --error-bg: #7f1d1d;
    --error-text: #fca5a5;
}

/* Dark mode scrollbar */
body.dark-mode ::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

body.dark-mode ::-webkit-scrollbar-track {
    background: var(--bg-secondary);
}

body.dark-mode ::-webkit-scrollbar-thumb {
    background: #4a4a5a;
    border-radius: 5px;
}

body.dark-mode ::-webkit-scrollbar-thumb:hover {
    background: #5a5a6a;
}

body.dark-mode {
    scrollbar-color: #4a4a5a var(--bg-secondary);
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    background: var(--bg-primary);
    min-height: 100vh;
    font-size: 12px;
    color: var(--text-primary);
    transition: background 0.3s, color 0.3s;
    overscroll-behavior: none;
}

/* Prevent pull-to-refresh and overscroll when dragging */
html {
    overscroll-behavior: none;
}

/* Prevent scrolling when actively dragging/resizing */
body.is-dragging,
body.is-resizing {
    overflow: hidden;
    touch-action: none;
}

header {
    background: var(--bg-header);
    color: white;
    padding: 15px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: sticky;
    top: 0;
    z-index: 10002;
    transition: background 0.3s;
}

header h1 {
    font-size: 1.5rem;
}

.header-title-area {
    display: flex;
    align-items: center;
    gap: 10px;
}

.header-settings-btn {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    width: 28px;
    height: 28px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.15s;
}

.header-settings-btn:hover {
    background: rgba(255,255,255,0.3);
}

.toolboard-version {
    font-size: 10px;
    opacity: 0.7;
    font-weight: normal;
    margin-left: 8px;
    background: rgba(255,255,255,0.15);
    padding: 2px 8px;
    border-radius: 10px;
}

.noteboard-settings {
    position: absolute;
    top: 100%;
    left: 20px;
    background: var(--bg-secondary);
    border-radius: 6px;
    box-shadow: 0 4px 20px var(--shadow-heavy);
    padding: 12px;
    z-index: 10001;
    min-width: 250px;
    display: none;
    color: var(--text-primary);
}

.noteboard-settings.open {
    display: block;
}

.noteboard-settings label {
    display: block;
    font-size: 11px;
    color: var(--text-secondary);
    margin-bottom: 4px;
    font-weight: 500;
}

.noteboard-settings input[type="text"] {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    margin-bottom: 10px;
    background: var(--input-bg);
    color: var(--text-primary);
}

.noteboard-settings input[type="text"]:focus {
    outline: none;
    border-color: #3498db;
}

.header-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

.header-controls button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: background 0.2s;
}

.board-selector-wrapper {
    position: relative;
}

#boardSelector {
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
    background: #9b59b6;
    color: white;
    min-width: 150px;
    appearance: none;
    -webkit-appearance: none;
    padding-right: 30px;
}

#boardSelector:hover {
    background: #8e44ad;
}

.board-selector-wrapper::after {
    content: '▼';
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    color: white;
    font-size: 10px;
    pointer-events: none;
}

#editVariablesBtn {
    background: #3498db;
    color: white;
}

#editVariablesBtn:hover {
    background: #2980b9;
}

#addNoteBtn {
    background: #27ae60;
    color: white;
}

#addNoteBtn:hover {
    background: #219a52;
}

#deleteBoardBtn {
    background: #e74c3c;
    color: white;
}

#deleteBoardBtn:hover {
    background: #c0392b;
}

#deleteBoardBtn:disabled {
    background: #bdc3c7;
    cursor: not-allowed;
}

#importExportBtn {
    background: #1abc9c;
    color: white;
}

#importExportBtn:hover {
    background: #16a085;
}

/* Import/Export Modal */
.import-export-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--overlay-bg);
    z-index: 10010;
    justify-content: center;
    align-items: center;
}

.import-export-modal.open {
    display: flex;
}

.import-export-content {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
}

.import-export-content h2 {
    margin-bottom: 15px;
    color: var(--text-heading);
}

.import-export-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 10px;
}

.import-export-tab {
    padding: 8px 16px;
    border: none;
    background: var(--bg-tertiary);
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    color: var(--text-primary);
}

.import-export-tab.active {
    background: #3498db;
    color: white;
}

.import-export-note {
    display: none;
    margin-bottom: 15px;
}

.import-export-note.active {
    display: block;
}

.import-export-note h3 {
    margin-bottom: 10px;
    color: var(--text-heading);
    font-size: 14px;
}

.export-options {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.export-option {
    display: flex;
    align-items: center;
    gap: 10px;
}

.export-option label {
    flex: 1;
}

.export-btn, .import-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
}

.export-btn {
    background: #27ae60;
    color: white;
}

.export-btn:hover {
    background: #219a52;
}

.import-btn {
    background: #3498db;
    color: white;
}

.import-btn:hover {
    background: #2980b9;
}

.checkbox-list {
    max-height: 200px;
    overflow-y: auto;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 10px;
    margin-bottom: 10px;
    background: var(--bg-tertiary);
}

.checkbox-list label {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 5px 0;
    cursor: pointer;
    color: var(--text-primary);
}

.checkbox-list label:hover {
    background: var(--table-hover);
}

.import-textarea {
    width: 100%;
    height: 150px;
    font-family: monospace;
    font-size: 12px;
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    resize: vertical;
    margin-bottom: 10px;
    background: var(--input-bg);
    color: var(--text-primary);
}

.import-file-input {
    margin-bottom: 10px;
}

.import-export-close {
    float: right;
    font-size: 24px;
    cursor: pointer;
    color: var(--text-muted);
    line-height: 1;
}

.import-export-close:hover {
    color: var(--text-heading);
}

.select-all-row {
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 8px;
    margin-bottom: 8px;
}

.import-result {
    padding: 10px;
    border-radius: 4px;
    margin-top: 10px;
    font-size: 13px;
}

.import-result.success {
    background: var(--success-bg);
    color: var(--success-text);
}

.import-result.error {
    background: var(--error-bg);
    color: var(--error-text);
}

main#noteboard {
    position: relative;
    min-height: calc(100vh - 60px);
    padding: 20px;
}

.note {
    position: absolute;
    background: var(--bg-secondary);
    border-radius: 8px;
    box-shadow: 0 2px 10px var(--shadow-light);
    overflow: visible;
    transition: box-shadow 0.2s, background 0.3s;
    min-width: 150px;
    min-height: 100px;
    display: flex;
    flex-direction: column;
}

/* Resize handles */
.resize-handle {
    position: absolute;
    background: transparent;
    z-index: 10;
    opacity: 0;
    transition: opacity 0.15s, background 0.15s;
    touch-action: none;
}

.note:hover .resize-handle,
.note:active .resize-handle {
    opacity: 1;
}

.resize-handle:hover {
    background: rgba(52, 152, 219, 0.4);
}

.resize-handle.active {
    background: rgba(52, 152, 219, 0.6);
    opacity: 1;
}

/* Corner handles */
.resize-handle-nw {
    top: -4px;
    left: -4px;
    width: 12px;
    height: 12px;
    cursor: nw-resize;
    border-radius: 4px 0 0 0;
}

.resize-handle-ne {
    top: -4px;
    right: -4px;
    width: 12px;
    height: 12px;
    cursor: ne-resize;
    border-radius: 0 4px 0 0;
}

.resize-handle-sw {
    bottom: -4px;
    left: -4px;
    width: 12px;
    height: 12px;
    cursor: sw-resize;
    border-radius: 0 0 0 4px;
}

.resize-handle-se {
    bottom: -4px;
    right: -4px;
    width: 12px;
    height: 12px;
    cursor: se-resize;
    border-radius: 0 0 4px 0;
}

/* Visible resize grip indicator on SE corner */
.resize-handle-se::after {
    content: '';
    position: absolute;
    right: 2px;
    bottom: 2px;
    width: 8px;
    height: 8px;
    border-right: 2px solid rgba(52, 152, 219, 0.5);
    border-bottom: 2px solid rgba(52, 152, 219, 0.5);
    opacity: 0;
    transition: opacity 0.15s;
}

.note:hover .resize-handle-se::after {
    opacity: 1;
}

/* Edge handles */
.resize-handle-n {
    top: -4px;
    left: 12px;
    right: 12px;
    height: 8px;
    cursor: n-resize;
}

.resize-handle-s {
    bottom: -4px;
    left: 12px;
    right: 12px;
    height: 8px;
    cursor: s-resize;
}

.resize-handle-w {
    top: 12px;
    bottom: 12px;
    left: -4px;
    width: 8px;
    cursor: w-resize;
}

.resize-handle-e {
    top: 12px;
    bottom: 12px;
    right: -4px;
    width: 8px;
    cursor: e-resize;
}

.note:hover {
    box-shadow: 0 4px 20px var(--shadow-medium);
}

.note.dragging {
    opacity: 0.9;
    box-shadow: 0 8px 30px var(--shadow-heavy);
    z-index: 1000 !important;
}

.note-header {
    background: var(--bg-note-header);
    color: white;
    padding: 10px 15px;
    font-weight: bold;
    font-size: 0.95rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: grab;
    user-select: none;
    flex-shrink: 0;
    border-radius: 8px 8px 0 0;
    transition: background 0.3s;
}

.note-header:active {
    cursor: grabbing;
}

.note-header {
    touch-action: none;
}

.note-header .drag-handle {
    opacity: 0.7;
}

.note-header .header-buttons {
    display: flex;
    gap: 4px;
    align-items: center;
}

.note-header .header-btn {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    width: 20px;
    height: 20px;
    border-radius: 3px;
    cursor: pointer;
    font-size: 11px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transition: opacity 0.15s, background 0.15s;
    padding: 0;
}

.note:hover .header-btn {
    opacity: 1;
}

.header-btn:hover {
    background: rgba(255,255,255,0.35);
}

.note.minimized .note-content {
    display: none;
}

.note.minimized {
    min-height: auto !important;
    height: auto !important;
}

.note.minimized .resize-handle {
    display: none;
}

.note.minimized .note-header {
    border-radius: 8px;
}

.minimize-btn.minimized {
    transform: rotate(180deg);
}

/* Fullscreen mode */
.note.fullscreen {
    position: fixed !important;
    top: 56px !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: calc(100vh - 56px) !important;
    z-index: 10001 !important;
    border-radius: 0 !important;
    margin: 0 !important;
}

.note.fullscreen .note-header {
    border-radius: 0;
}

.note.fullscreen .note-content {
    max-height: calc(100vh - 56px - 36px);
    overflow: auto;
}

.note.fullscreen .resize-handle {
    display: none;
}

.fullscreen-btn.active {
    background: rgba(255,255,255,0.4);
}

/* Fullscreen overlay backdrop */
.fullscreen-backdrop {
    display: none;
    position: fixed;
    top: 56px;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--overlay-bg);
    z-index: 10000;
}

.fullscreen-backdrop.active {
    display: block;
}

/* Note settings popup - modal style */
.note-settings-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--overlay-bg);
    z-index: 10010;
    justify-content: center;
    align-items: center;
}

.note-settings-overlay.open {
    display: flex;
}

.note-settings {
    background: var(--bg-secondary);
    border-radius: 8px;
    box-shadow: 0 4px 20px var(--shadow-heavy);
    padding: 20px;
    min-width: 280px;
    max-width: 90%;
    color: var(--text-primary);
    font-weight: normal;
}

.note-settings-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border-light);
}

.note-settings-header h3 {
    margin: 0;
    font-size: 16px;
    color: var(--text-heading);
}

.note-settings-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: var(--text-secondary);
    padding: 0;
    line-height: 1;
}

.note-settings-close:hover {
    color: var(--text-primary);
}

.note-settings label {
    display: block;
    font-size: 11px;
    color: var(--text-secondary);
    margin-bottom: 4px;
    font-weight: 500;
}

.note-settings input[type="text"] {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid var(--border-color);
    background: var(--input-bg);
    color: var(--text-primary);
    border-radius: 4px;
    font-size: 12px;
    margin-bottom: 10px;
}

.note-settings input[type="text"]:focus {
    outline: none;
    border-color: #3498db;
}

.color-picker-row {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    margin-bottom: 12px;
}

.color-swatch {
    width: 24px;
    height: 24px;
    border-radius: 4px;
    cursor: pointer;
    border: 2px solid transparent;
    transition: transform 0.1s, border-color 0.1s;
}

.color-swatch:hover {
    transform: scale(1.15);
}

.color-swatch.selected {
    border-color: #333;
}

/* Content editor */
.edit-content-btn {
    width: 100%;
    padding: 6px 12px;
    background: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 11px;
    margin-top: 4px;
}

.edit-content-btn:hover {
    background: #2980b9;
}

.duplicate-note-btn {
    width: 100%;
    padding: 6px 12px;
    background: #9b59b6;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 11px;
    margin-top: 4px;
}

.duplicate-note-btn:hover {
    background: #8e44ad;
}

.export-note-btn {
    width: 100%;
    padding: 6px 12px;
    background: #1abc9c;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 11px;
    margin-top: 4px;
}

.export-note-btn:hover {
    background: #16a085;
}

.export-png-btn {
    width: 100%;
    padding: 6px 12px;
    background: #e67e22;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 11px;
    margin-top: 4px;
}

.export-png-btn:hover {
    background: #d35400;
}

.delete-note-btn {
    width: 100%;
    padding: 6px 12px;
    background: #e74c3c;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 11px;
    margin-top: 4px;
}

.delete-note-btn:hover {
    background: #c0392b;
}

.content-editor-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--overlay-bg);
    z-index: 20000;
    align-items: center;
    justify-content: center;
}

.content-editor-overlay.open {
    display: flex;
}

.content-editor {
    background: var(--bg-secondary);
    border-radius: 8px;
    width: 95%;
    max-width: 1400px;
    height: 90vh;
    min-width: 500px;
    min-height: 300px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: absolute;
    box-shadow: 0 10px 50px var(--shadow-heavy);
}

.content-editor-resize {
    position: absolute;
    background: transparent;
    z-index: 10;
    touch-action: none;
}

.content-editor-resize-e {
    top: 10px;
    bottom: 10px;
    right: -4px;
    width: 8px;
    cursor: e-resize;
}

.content-editor-resize-s {
    left: 10px;
    right: 10px;
    bottom: -4px;
    height: 8px;
    cursor: s-resize;
}

.content-editor-resize-se {
    right: -4px;
    bottom: -4px;
    width: 16px;
    height: 16px;
    cursor: se-resize;
}

.content-editor-header {
    padding: 15px 20px;
    background: var(--bg-note-header);
    color: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: grab;
    user-select: none;
    touch-action: none;
}

.content-editor-header:active {
    cursor: grabbing;
}

.content-editor-header h3 {
    margin: 0;
    font-size: 1rem;
    pointer-events: none;
}

.content-editor-close {
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    line-height: 1;
}

.content-editor-body {
    display: flex;
    flex: 1;
    min-height: 0;
}

.content-editor-input {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 200px;
}

.content-editor-resizer {
    width: 6px;
    background: var(--border-color);
    cursor: col-resize;
    flex-shrink: 0;
    transition: background 0.15s;
    touch-action: none;
}

.content-editor-resizer:hover,
.content-editor-resizer.active {
    background: #3498db;
}

.content-editor-preview {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 200px;
}

.content-editor-label {
    padding: 8px 12px;
    background: var(--bg-tertiary);
    font-size: 11px;
    color: var(--text-secondary);
    font-weight: 500;
    border-bottom: 1px solid var(--border-color);
}

.content-editor-textarea {
    flex: 1;
    border: none;
    padding: 12px;
    font-family: 'Monaco', 'Menlo', monospace;
    font-size: 12px;
    resize: none;
    outline: none;
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.content-editor-preview-area {
    flex: 1;
    padding: 12px;
    overflow: auto;
    font-size: 12px;
    background: var(--bg-secondary);
    color: var(--text-primary);
}

.content-editor-footer {
    padding: 12px 20px;
    background: var(--bg-tertiary);
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: flex-end;
    gap: 10px;
}

.content-editor-footer button {
    padding: 8px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
}

.content-editor-save {
    background: #27ae60;
    color: white;
}

.content-editor-save:hover {
    background: #219a52;
}

.content-editor-reset {
    background: #e74c3c;
    color: white;
}

.content-editor-reset:hover {
    background: #c0392b;
}

.content-editor-cancel {
    background: #95a5a6;
    color: white;
}

.content-editor-cancel:hover {
    background: #7f8c8d;
}

/* Markdown rendered styles */
.markdown-content h1, .markdown-content h2, .markdown-content h3,
.markdown-content h4, .markdown-content h5, .markdown-content h6 {
    margin-top: 0.5em;
    margin-bottom: 0.3em;
    color: var(--text-heading);
}

.markdown-content h1 { font-size: 1.4em; }
.markdown-content h2 { font-size: 1.2em; }
.markdown-content h3 { font-size: 1.1em; }

.markdown-content p {
    margin: 0.5em 0;
}

.markdown-content ul, .markdown-content ol {
    margin: 0.5em 0;
    padding-left: 1.5em;
}

.markdown-content code {
    background: var(--code-bg);
    padding: 2px 5px;
    border-radius: 3px;
    font-family: monospace;
    font-size: 0.9em;
}

.markdown-content pre {
    background: var(--code-bg);
    padding: 10px;
    border-radius: 4px;
    overflow-x: auto;
}

.markdown-content pre code {
    background: none;
    padding: 0;
}

.markdown-content blockquote {
    border-left: 3px solid #3498db;
    margin: 0.5em 0;
    padding-left: 1em;
    color: var(--text-secondary);
}

.markdown-content hr {
    border: none;
    border-top: 1px solid var(--border-color);
    margin: 1em 0;
}

.markdown-content strong {
    font-weight: 600;
}

.markdown-content a {
    color: #3498db;
}

.markdown-content img {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
    border-radius: 4px;
    margin: 0.5em 0;
    display: block;
}

.markdown-content table {
    margin: 0.5em 0;
}

.note-content {
    padding: 15px;
    overflow: auto;
    flex: 1;
    min-height: 0;
}

.note.resizing {
    user-select: none;
}

.note.resizing .note-content {
    pointer-events: none;
}

/* Tables */
table {
    border-collapse: collapse;
    width: 100%;
    font-size: 11px;
}

th, td {
    border: 1px solid var(--border-color);
    padding: 6px 8px;
    text-align: left;
}

th {
    background: var(--bg-tertiary);
    font-weight: 600;
}

tr:nth-child(even) {
    background: var(--table-stripe);
}

tr:hover {
    background: var(--table-hover);
}

/* Checklist Widget */
.checklist-items {
    list-style: none;
    padding: 0;
    margin: 0;
}

.checklist-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px 8px;
    background: var(--bg-tertiary);
    border-radius: 4px;
    margin-bottom: 4px;
    transition: background 0.15s, opacity 0.15s, box-shadow 0.15s;
}

.checklist-item:hover {
    background: var(--table-hover);
}

.checklist-item.dragging {
    opacity: 0.5;
    box-shadow: 0 2px 8px var(--shadow-medium);
}

.checklist-item.drag-over {
    border-top: 2px solid #3498db;
    margin-top: -2px;
}

.checklist-item.completed {
    opacity: 0.6;
}

.checklist-item.completed .checklist-text {
    text-decoration: line-through;
    color: var(--text-muted);
}

.checklist-item.in_progress .checklist-status {
    background: #f39c12;
    border-color: #f39c12;
}

.checklist-item.in_progress .checklist-status::after {
    content: '▶';
    color: white;
    font-size: 9px;
    margin-left: 1px;
}

.checklist-drag {
    cursor: grab;
    color: var(--text-muted);
    font-size: 12px;
    padding: 2px;
    opacity: 0.4;
    transition: opacity 0.15s;
}

.checklist-item:hover .checklist-drag {
    opacity: 1;
}

.checklist-drag:active {
    cursor: grabbing;
}

.checklist-status {
    width: 18px;
    height: 18px;
    min-width: 18px;
    border: 2px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    background: transparent;
}

.checklist-status:hover {
    border-color: #3498db;
}

.checklist-item.completed .checklist-status {
    background: #27ae60;
    border-color: #27ae60;
}

.checklist-item.completed .checklist-status::after {
    content: '✓';
    color: white;
    font-size: 12px;
    font-weight: bold;
}

.checklist-text {
    flex: 1;
    font-size: 13px;
    word-break: break-word;
    cursor: text;
    padding: 2px 4px;
    border-radius: 3px;
    min-height: 1.4em;
}

.checklist-text:hover {
    background: rgba(0,0,0,0.05);
}

.checklist-text:focus {
    outline: none;
    background: var(--input-bg);
    box-shadow: 0 0 0 2px #3498db;
}

.checklist-actions {
    display: flex;
    gap: 2px;
    opacity: 0;
    transition: opacity 0.15s;
}

.checklist-item:hover .checklist-actions {
    opacity: 1;
}

.checklist-btn {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 14px;
    padding: 2px 5px;
    border-radius: 3px;
    transition: color 0.15s, background 0.15s;
}

.checklist-btn:hover {
    background: rgba(0,0,0,0.1);
    color: var(--text-primary);
}

.checklist-btn.delete:hover {
    color: #e74c3c;
    background: rgba(231, 76, 60, 0.1);
}

/* Sub-items */
.checklist-subitems {
    list-style: none;
    padding: 0;
    margin: 4px 0 0 24px;
    border-left: 2px solid var(--border-light);
    padding-left: 8px;
}

.checklist-subitems .checklist-item {
    background: transparent;
    padding: 4px 6px;
    margin-bottom: 2px;
}

.checklist-subitems .checklist-item:hover {
    background: var(--bg-tertiary);
}

.checklist-add-sub {
    font-size: 11px;
    color: var(--text-muted);
    cursor: pointer;
    padding: 4px 8px;
    margin-left: 24px;
    opacity: 0;
    transition: opacity 0.15s;
}

.checklist-item-wrapper:hover .checklist-add-sub {
    opacity: 1;
}

.checklist-add-sub:hover {
    color: #3498db;
}

.checklist-input:focus {
    outline: none;
    border-color: #3498db;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: var(--overlay-bg);
    overflow: auto;
}

.modal-content {
    background: var(--bg-secondary);
    margin: 50px auto;
    padding: 20px;
    width: 90%;
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    border-radius: 8px;
}

.modal-content h2 {
    margin-bottom: 20px;
}

.close {
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    color: var(--text-secondary);
}

.close:hover {
    color: #e74c3c;
}

/* Calendar Widget Styles */
.note-content:has(.calendar-widget) {
    display: flex;
    flex-direction: column;
}

.calendar-widget {
    padding: 10px;
    font-size: 12px;
    display: flex;
    flex-direction: column;
    flex: 1;
    width: 100%;
    box-sizing: border-box;
    min-height: 0;
}

.calendar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    gap: 10px;
    flex-shrink: 0;
}

.calendar-year-nav {
    display: flex;
    align-items: center;
    gap: 8px;
}

.calendar-year-nav button {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    color: var(--text-primary);
    font-size: 14px;
}

.calendar-year-nav button:hover {
    background: var(--table-hover);
}

.calendar-year-nav span {
    font-weight: 600;
    font-size: 16px;
    min-width: 50px;
    text-align: center;
}

.calendar-manage-btn {
    background: #3498db;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 6px 12px;
    cursor: pointer;
    font-size: 11px;
}

.calendar-manage-btn:hover {
    background: #2980b9;
}

.calendar-year-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 12px;
    flex: 1;
    min-height: 0;
}

.calendar-month {
    background: var(--bg-tertiary);
    border-radius: 6px;
    padding: 8px;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.calendar-month-name {
    font-weight: 600;
    text-align: center;
    margin-bottom: 6px;
    font-size: 11px;
    color: var(--text-heading);
    flex-shrink: 0;
}

.calendar-month-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    grid-template-rows: auto repeat(6, 1fr);
    gap: 1px;
    flex: 1;
    min-height: 0;
}

.calendar-dow {
    text-align: center;
    font-size: 8px;
    color: var(--text-muted);
    padding: 2px 0;
}

.calendar-day {
    text-align: center;
    padding: 2px;
    font-size: 9px;
    position: relative;
    min-height: 16px;
    border-radius: 2px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.calendar-day:hover {
    background: var(--table-hover);
}

.calendar-day.other-month {
    cursor: default;
}

.calendar-day.today {
    background: #3498db;
    color: white;
    border-radius: 50%;
    font-weight: 600;
}

.calendar-day.other-month {
    color: var(--text-muted);
    opacity: 0.4;
}

.calendar-event-dots {
    display: flex;
    justify-content: center;
    gap: 1px;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
}

.calendar-event-dot {
    width: 4px;
    height: 4px;
    border-radius: 50%;
}

.calendar-legend {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    padding-top: 10px;
    border-top: 1px solid var(--border-light);
    font-size: 11px;
    flex-shrink: 0;
}

.calendar-legend-item {
    display: flex;
    align-items: center;
    gap: 4px;
}

.calendar-legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
}

.calendar-legend-count {
    color: var(--text-muted);
    margin-left: 2px;
}

/* Calendar Management Modal */
.calendar-manage-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--overlay-bg);
    z-index: 10020;
    justify-content: center;
    align-items: center;
}

.calendar-manage-modal.open {
    display: flex;
}

.calendar-manage-content {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 450px;
    max-height: 80vh;
    overflow-y: auto;
}

.calendar-manage-content h3 {
    margin-bottom: 15px;
    color: var(--text-heading);
}

.calendar-manage-close {
    float: right;
    font-size: 24px;
    cursor: pointer;
    color: var(--text-muted);
    line-height: 1;
}

.calendar-manage-close:hover {
    color: var(--text-heading);
}

.calendar-list {
    margin-bottom: 15px;
}

.calendar-list-item {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    margin-bottom: 8px;
}

.calendar-list-color {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    flex-shrink: 0;
}

.calendar-list-name {
    flex: 1;
    font-weight: 500;
}

.calendar-list-count {
    color: var(--text-muted);
    font-size: 11px;
}

.calendar-list-remove {
    background: none;
    border: none;
    color: #e74c3c;
    cursor: pointer;
    font-size: 16px;
    padding: 2px 6px;
}

.calendar-list-remove:hover {
    background: rgba(231, 76, 60, 0.1);
    border-radius: 4px;
}

.calendar-add-form {
    border-top: 1px solid var(--border-light);
    padding-top: 15px;
}

.calendar-add-form h4 {
    margin-bottom: 10px;
    font-size: 13px;
    color: var(--text-heading);
}

.calendar-add-row {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
}

.calendar-add-name {
    flex: 1;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 13px;
    background: var(--input-bg);
    color: var(--text-primary);
}

.calendar-color-picker {
    display: flex;
    gap: 4px;
    margin-bottom: 10px;
}

.calendar-color-option {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
}

.calendar-color-option:hover {
    transform: scale(1.1);
}

.calendar-color-option.selected {
    border-color: var(--text-heading);
}

.calendar-add-btn {
    background: #27ae60;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 8px 16px;
    cursor: pointer;
    font-size: 12px;
}

.calendar-add-btn:hover {
    background: #229954;
}

.calendar-import-section {
    border-top: 1px solid var(--border-light);
    padding-top: 15px;
    margin-top: 15px;
}

.calendar-import-section h4 {
    margin-bottom: 10px;
    font-size: 13px;
    color: var(--text-heading);
}

.calendar-import-row {
    display: flex;
    gap: 8px;
    align-items: center;
}

.calendar-import-file {
    flex: 1;
}

.calendar-import-select {
    padding: 6px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-size: 12px;
    background: var(--input-bg);
    color: var(--text-primary);
}

/* Calendar Day Tooltip */
.calendar-day-tooltip {
    position: absolute;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 8px;
    min-width: 150px;
    max-width: 250px;
    z-index: 10030;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-size: 11px;
}

.calendar-day-tooltip-date {
    font-weight: 600;
    margin-bottom: 6px;
    color: var(--text-heading);
}

.calendar-day-tooltip-event {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 3px 0;
}

.calendar-day-tooltip-text {
    flex: 1;
}

.calendar-event-delete {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 14px;
    padding: 0 4px;
    line-height: 1;
    opacity: 0.5;
}

.calendar-event-delete:hover {
    color: #e74c3c;
    opacity: 1;
}

.calendar-day-tooltip-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    flex-shrink: 0;
}

.calendar-day-add-form {
    display: flex;
    gap: 4px;
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid var(--border-light);
}

.calendar-day-add-input {
    flex: 1;
    min-width: 0;
    padding: 4px 6px;
    border: 1px solid var(--border-color);
    border-radius: 3px;
    font-size: 11px;
    background: var(--input-bg);
    color: var(--text-primary);
}

.calendar-day-add-select {
    padding: 4px;
    border: 1px solid var(--border-color);
    border-radius: 3px;
    font-size: 10px;
    background: var(--input-bg);
    color: var(--text-primary);
    max-width: 80px;
}

.calendar-day-add-btn {
    padding: 4px 8px;
    background: #27ae60;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
}

.calendar-day-add-btn:hover {
    background: #229954;
}

/* Diff Viewer Widget Styles */
.note-content:has(.diff-widget) {
    display: flex;
    flex-direction: column;
}

.diff-widget {
    padding: 10px;
    font-size: 12px;
    display: flex;
    flex-direction: column;
    flex: 1;
    width: 100%;
    box-sizing: border-box;
    min-height: 0;
}

.diff-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    gap: 10px;
    flex-shrink: 0;
    flex-wrap: wrap;
}

.diff-mode-toggle {
    display: flex;
    gap: 4px;
}

.diff-mode-btn {
    padding: 6px 12px;
    border: 1px solid var(--border-color);
    background: var(--bg-tertiary);
    color: var(--text-primary);
    cursor: pointer;
    font-size: 11px;
    border-radius: 4px;
}

.diff-mode-btn:first-child {
    border-radius: 4px 0 0 4px;
}

.diff-mode-btn:last-child {
    border-radius: 0 4px 4px 0;
}

.diff-mode-btn.active {
    background: #3498db;
    color: white;
    border-color: #3498db;
}

.diff-view-options {
    display: flex;
    align-items: center;
    gap: 8px;
}

.diff-view-btn {
    padding: 5px 10px;
    border: 1px solid var(--border-color);
    background: var(--bg-tertiary);
    color: var(--text-primary);
    cursor: pointer;
    font-size: 10px;
    border-radius: 3px;
}

.diff-view-btn.active {
    background: #27ae60;
    color: white;
    border-color: #27ae60;
}

.diff-whitespace-toggle {
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 10px;
    color: var(--text-secondary);
}

.diff-whitespace-toggle input {
    margin: 0;
}

.diff-edit-container {
    display: flex;
    gap: 10px;
    flex: 1;
    min-height: 0;
}

.diff-edit-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
}

.diff-edit-pane label {
    font-weight: 600;
    margin-bottom: 6px;
    font-size: 11px;
    color: var(--text-heading);
}

.diff-edit-pane textarea {
    flex: 1;
    resize: none;
    padding: 8px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-family: monospace;
    font-size: 12px;
    background: var(--input-bg);
    color: var(--text-primary);
    min-height: 100px;
}

.diff-edit-pane textarea:focus {
    outline: none;
    border-color: #3498db;
}

.diff-edit-resizer {
    width: 6px;
    background: var(--border-color);
    cursor: col-resize;
    border-radius: 3px;
    flex-shrink: 0;
}

.diff-edit-resizer:hover {
    background: #3498db;
}

.diff-view-container {
    flex: 1;
    min-height: 0;
    display: none;
    flex-direction: column;
}

.diff-view-container.active {
    display: flex;
}

.diff-edit-container.hidden {
    display: none;
}

.diff-output {
    flex: 1;
    overflow: auto;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background: var(--bg-tertiary);
    font-family: monospace;
    font-size: 12px;
}

.diff-split-view {
    display: flex;
    min-height: 100%;
}

.diff-split-pane {
    flex: 1;
    min-width: 0;
}

.diff-split-pane:first-child {
    border-right: 1px solid var(--border-color);
}

.diff-split-header {
    padding: 6px 10px;
    background: var(--bg-note-header);
    color: white;
    font-weight: 600;
    font-size: 11px;
    position: sticky;
    top: 0;
}

.diff-unified-view {
    min-height: 100%;
}

.diff-line {
    display: flex;
    line-height: 1.5;
    min-height: 20px;
}

.diff-gutter {
    width: 40px;
    padding: 0 6px;
    text-align: right;
    color: var(--text-muted);
    background: var(--bg-tertiary);
    border-right: 1px solid var(--border-light);
    flex-shrink: 0;
    font-size: 10px;
    user-select: none;
}

.diff-content {
    flex: 1;
    padding: 0 8px;
    white-space: pre-wrap;
    word-break: break-all;
    min-width: 0;
}

.diff-line.addition {
    background: rgba(39, 174, 96, 0.15);
}

.diff-line.addition .diff-gutter {
    background: rgba(39, 174, 96, 0.3);
    color: #27ae60;
}

.diff-line.deletion {
    background: rgba(231, 76, 60, 0.15);
}

.diff-line.deletion .diff-gutter {
    background: rgba(231, 76, 60, 0.3);
    color: #e74c3c;
}

.diff-line.unchanged {
    background: transparent;
}

.diff-prefix {
    width: 16px;
    text-align: center;
    flex-shrink: 0;
    font-weight: bold;
}

.diff-line.addition .diff-prefix {
    color: #27ae60;
}

.diff-line.deletion .diff-prefix {
    color: #e74c3c;
}

.diff-stats {
    display: flex;
    gap: 16px;
    padding: 8px 0;
    font-size: 11px;
    color: var(--text-secondary);
    border-top: 1px solid var(--border-light);
    margin-top: 8px;
    flex-shrink: 0;
}

.diff-stats-additions {
    color: #27ae60;
}

.diff-stats-deletions {
    color: #e74c3c;
}

.diff-empty-message {
    padding: 20px;
    text-align: center;
    color: var(--text-muted);
    font-style: italic;
}

/* Dark mode adjustments for diff */
body.dark-mode .diff-line.addition {
    background: rgba(39, 174, 96, 0.2);
}

body.dark-mode .diff-line.addition .diff-gutter {
    background: rgba(39, 174, 96, 0.35);
}

body.dark-mode .diff-line.deletion {
    background: rgba(231, 76, 60, 0.2);
}

body.dark-mode .diff-line.deletion .diff-gutter {
    background: rgba(231, 76, 60, 0.35);
}

/* Sequence Diagram Widget Styles */
.note-content:has(.seq-widget) {
    display: flex;
    flex-direction: column;
}

.seq-widget {
    padding: 10px;
    font-size: 12px;
    display: flex;
    flex-direction: column;
    flex: 1;
    width: 100%;
    box-sizing: border-box;
    min-height: 0;
}

.seq-toolbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    gap: 10px;
    flex-shrink: 0;
    flex-wrap: wrap;
}

.seq-mode-toggle {
    display: flex;
    gap: 4px;
}

.seq-mode-btn {
    padding: 6px 12px;
    border: 1px solid var(--border-color);
    background: var(--bg-tertiary);
    color: var(--text-primary);
    cursor: pointer;
    font-size: 11px;
    border-radius: 4px;
}

.seq-mode-btn:first-child {
    border-radius: 4px 0 0 4px;
}

.seq-mode-btn:last-child {
    border-radius: 0 4px 4px 0;
}

.seq-mode-btn.active {
    background: #3498db;
    color: white;
    border-color: #3498db;
}

.seq-help-btn {
    padding: 5px 10px;
    border: 1px solid var(--border-color);
    background: var(--bg-tertiary);
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 10px;
    border-radius: 3px;
}

.seq-help-btn:hover {
    background: var(--table-hover);
}

.seq-split-container {
    flex: 1;
    display: none;
    gap: 10px;
    min-height: 0;
}

.seq-split-container.active {
    display: flex;
}

.seq-split-container .seq-edit-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
}

.seq-split-container .seq-edit-pane textarea {
    flex: 1;
    resize: none;
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-family: monospace;
    font-size: 12px;
    background: var(--input-bg);
    color: var(--text-primary);
    min-height: 100px;
    line-height: 1.5;
}

.seq-split-container .seq-edit-pane textarea:focus {
    outline: none;
    border-color: #3498db;
}

.seq-split-container .seq-view-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background: var(--bg-tertiary);
    overflow: auto;
}

.seq-split-resizer {
    width: 6px;
    background: var(--border-color);
    cursor: col-resize;
    border-radius: 3px;
    flex-shrink: 0;
}

.seq-split-resizer:hover {
    background: #3498db;
}

.seq-edit-container {
    flex: 1;
    display: none;
    flex-direction: column;
    min-height: 0;
}

.seq-edit-container.active {
    display: flex;
}

.seq-edit-container textarea {
    flex: 1;
    resize: none;
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    font-family: monospace;
    font-size: 12px;
    background: var(--input-bg);
    color: var(--text-primary);
    min-height: 100px;
    line-height: 1.5;
}

.seq-edit-container textarea:focus {
    outline: none;
    border-color: #3498db;
}

.seq-edit-container textarea::placeholder {
    color: var(--text-muted);
}

.seq-view-container {
    flex: 1;
    min-height: 0;
    display: none;
    flex-direction: column;
    overflow: auto;
}

.seq-view-container.active {
    display: flex;
}

.seq-diagram {
    flex: 1;
    min-height: 200px;
    display: flex;
    justify-content: center;
    padding: 10px;
}

.seq-diagram svg {
    max-width: 100%;
    height: auto;
}

.seq-participant-box {
    fill: var(--bg-tertiary);
    stroke: var(--border-color);
    stroke-width: 2;
}

.seq-participant-text {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 12px;
    font-weight: 600;
    fill: var(--text-primary);
    text-anchor: middle;
    dominant-baseline: middle;
}

.seq-lifeline {
    stroke: var(--border-color);
    stroke-width: 1;
    stroke-dasharray: 5, 5;
}

.seq-arrow {
    stroke: var(--text-primary);
    stroke-width: 1.5;
    fill: none;
}

.seq-arrow-head {
    fill: var(--text-primary);
    stroke: none;
}

.seq-arrow.dashed {
    stroke-dasharray: 5, 3;
}

.seq-arrow-label {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 11px;
    fill: var(--text-primary);
    dominant-baseline: middle;
}

.seq-arrow-number {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 10px;
    font-weight: 700;
    fill: white;
}

.seq-arrow-number-bg {
    fill: #3498db;
}

.seq-arrow.dashed + .seq-arrow-number-bg,
.seq-dashed-number-bg {
    fill: #9b59b6;
}

.seq-self-arrow {
    stroke: var(--text-primary);
    stroke-width: 1.5;
    fill: none;
}

.seq-note-box {
    fill: #ffffcc;
    stroke: #cccc00;
    stroke-width: 1;
}

.seq-note-text {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 10px;
    fill: #333;
}

body.dark-mode .seq-note-box {
    fill: #4a4a2a;
    stroke: #8a8a3a;
}

body.dark-mode .seq-note-text {
    fill: #e4e4e7;
}

.seq-error-message {
    padding: 20px;
    text-align: center;
    color: var(--text-muted);
    font-style: italic;
}

.seq-help-text {
    font-size: 10px;
    color: var(--text-muted);
    padding: 8px 0;
    border-top: 1px solid var(--border-light);
    margin-top: 8px;
    flex-shrink: 0;
}

.seq-help-text code {
    background: var(--code-bg);
    padding: 1px 4px;
    border-radius: 3px;
    font-family: monospace;
}

/* Sequence Diagram Help Modal */
.seq-help-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--overlay-bg);
    z-index: 10015;
    justify-content: center;
    align-items: center;
}

.seq-help-modal.open {
    display: flex;
}

.seq-help-content {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
}

.seq-help-content h3 {
    margin-bottom: 12px;
    color: var(--text-heading);
}

.seq-help-content pre {
    background: var(--code-bg);
    padding: 12px;
    border-radius: 4px;
    font-size: 11px;
    overflow-x: auto;
    margin: 10px 0;
}

.seq-help-content p {
    margin: 8px 0;
    font-size: 12px;
    color: var(--text-secondary);
}

.seq-help-close {
    float: right;
    font-size: 24px;
    cursor: pointer;
    color: var(--text-muted);
    line-height: 1;
}

.seq-help-close:hover {
    color: var(--text-heading);
}

/* Dark mode adjustments for sequence diagram */
body.dark-mode .seq-participant-box {
    fill: var(--bg-tertiary);
    stroke: var(--border-color);
}

body.dark-mode .seq-arrow-number-bg {
    fill: #2980b9;
}

body.dark-mode .seq-dashed-number-bg {
    fill: #8e44ad;
}

/* Feature Selection Modal */
.feature-select-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--overlay-bg);
    z-index: 10010;
    justify-content: center;
    align-items: center;
}

.feature-select-modal.open {
    display: flex;
}

.feature-select-content {
    background: var(--bg-secondary);
    border-radius: 8px;
    padding: 20px;
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
}

.feature-select-content h2 {
    margin-bottom: 15px;
    color: var(--text-heading);
}

.feature-select-close {
    float: right;
    font-size: 24px;
    cursor: pointer;
    color: var(--text-muted);
    line-height: 1;
}

.feature-select-close:hover {
    color: var(--text-heading);
}

.feature-select-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.feature-select-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.15s, border-color 0.15s;
}

.feature-select-item:hover {
    background: var(--bg-tertiary);
    border-color: #3498db;
}

.feature-select-item:active {
    background: var(--table-hover);
}

.feature-select-icon {
    font-size: 24px;
    width: 40px;
    text-align: center;
    flex-shrink: 0;
}

.feature-select-info {
    flex: 1;
}

.feature-select-name {
    font-weight: 600;
    color: var(--text-heading);
    margin-bottom: 2px;
}

.feature-select-description {
    font-size: 11px;
    color: var(--text-muted);
}

/* Number formatting */
.currency::before {
    content: '$';
}

.percent::after {
    content: '%';
}

/* Snap guides */
.snap-guide {
    opacity: 0.8;
    box-shadow: 0 0 4px rgba(52, 152, 219, 0.8);
}

.note.snapping {
    transition: none;
}

/* Responsive */
@media (max-width: 768px) {
    header {
        flex-direction: column;
        gap: 10px;
        padding: 10px 15px;
    }

    .header-title-area {
        width: 100%;
        justify-content: center;
    }

    header h1 {
        font-size: 1.2rem;
    }

    .header-controls {
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        width: 100%;
    }

    .header-controls button {
        padding: 10px 14px;
        font-size: 0.85rem;
    }

    #boardSelector {
        min-width: 120px;
        padding: 10px 12px;
    }

    main#noteboard {
        padding: 10px;
    }

    .note {
        min-width: 120px;
        min-height: 80px;
    }

    .note-header {
        padding: 12px 10px;
        font-size: 0.85rem;
    }

    /* Larger touch targets for resize handles on mobile */
    .resize-handle {
        opacity: 0.5;
    }

    .resize-handle-nw,
    .resize-handle-ne,
    .resize-handle-sw,
    .resize-handle-se {
        width: 24px;
        height: 24px;
    }

    .resize-handle-nw {
        top: -8px;
        left: -8px;
    }

    .resize-handle-ne {
        top: -8px;
        right: -8px;
    }

    .resize-handle-sw {
        bottom: -8px;
        left: -8px;
    }

    .resize-handle-se {
        bottom: -8px;
        right: -8px;
        /* Add visible indicator for primary resize handle */
        background: rgba(52, 152, 219, 0.3);
        border-radius: 0 0 8px 0;
    }

    .resize-handle-n,
    .resize-handle-s {
        height: 16px;
        left: 24px;
        right: 24px;
    }

    .resize-handle-n {
        top: -8px;
    }

    .resize-handle-s {
        bottom: -8px;
    }

    .resize-handle-w,
    .resize-handle-e {
        width: 16px;
        top: 24px;
        bottom: 24px;
    }

    .resize-handle-w {
        left: -8px;
    }

    .resize-handle-e {
        right: -8px;
    }

    /* Content editor adjustments for mobile */
    .content-editor {
        width: 100% !important;
        height: 100vh !important;
        max-width: 100% !important;
        min-width: unset !important;
        border-radius: 0;
        left: 0 !important;
        top: 0 !important;
    }

    .content-editor-body {
        flex-direction: column;
    }

    .content-editor-resizer {
        width: 100%;
        height: 6px;
        cursor: row-resize;
    }

    .content-editor-input,
    .content-editor-preview {
        min-width: 100%;
        min-height: 150px;
    }

    /* Note settings modal adjustments */
    .note-settings {
        width: 90%;
        max-width: 320px;
    }

    /* Import/Export modal adjustments */
    .import-export-content {
        width: 95%;
        max-height: 90vh;
        padding: 15px;
    }

    /* Better tap feedback */
    .note-header .header-btn {
        opacity: 1;
        width: 28px;
        height: 28px;
    }

    .noteboard-settings {
        left: 10px;
        right: 10px;
        min-width: unset;
    }
}

/* Touch-specific improvements */
@media (pointer: coarse) {
    .note-header {
        cursor: grab;
        -webkit-user-select: none;
        user-select: none;
    }

    .resize-handle {
        opacity: 0.6;
    }

    .resize-handle-se {
        background: rgba(52, 152, 219, 0.4);
    }

    .note-header .header-btn {
        opacity: 1;
    }
}
    </style>
</head>
<body>
    <header id="mainHeader">
        <div class="header-title-area">
            <a href="https://toolboard.me" title="Visit Toolboard.me"><img alt="Toolboard Logo" style="width: 32px; height: 32px;" src="data:image/svg+xml,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%20300%20300%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%20%20%3Crect%20width%3D%22290%22%20height%3D%22290%22%20fill%3D%22%23444%22%20rx%3D%2210%22%20ry%3D%2210%22%20%2F%3E%20%20%3Cdefs%3E%20%20%20%20%3Cpattern%20id%3D%22peg-grid%22%20x%3D%2215%22%20y%3D%2215%22%20width%3D%2230%22%20height%3D%2230%22%20patternUnits%3D%22userSpaceOnUse%22%3E%20%20%20%20%20%20%3Ccircle%20cx%3D%2210%22%20cy%3D%2210%22%20r%3D%2210.5%22%20fill%3D%22%23000%22%20%2F%3E%20%20%20%20%3C%2Fpattern%3E%20%20%3C%2Fdefs%3E%20%20%3Crect%20x%3D%225%22%20y%3D%225%22%20width%3D%22275%22%20height%3D%22275%22%20fill%3D%22url(%23peg-grid)%22%20%2F%3E%20%20%3Cg%20fill%3D%22%23ff8%22%3E%20%20%20%20%3Ccircle%20cx%3D%2225%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2225%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2225%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2255%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2255%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2255%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2285%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2285%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%2285%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22205%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22205%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22205%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22235%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22235%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22235%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22265%22%20cy%3D%2225%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22265%22%20cy%3D%2255%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22265%22%20cy%3D%2285%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22115%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22115%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22115%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22145%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22145%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22145%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22175%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22175%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22175%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22205%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22205%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22205%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22235%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22235%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22235%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22115%22%20cy%3D%22265%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22145%22%20cy%3D%22265%22%20r%3D%2210.5%22%20%2F%3E%20%20%20%20%3Ccircle%20cx%3D%22175%22%20cy%3D%22265%22%20r%3D%2210.5%22%20%2F%3E%20%20%3C%2Fg%3E%3C%2Fsvg%3E"></a>
            <h1 id="noteboardTitle">My Toolboard</h1>
            <button id="noteboardSettingsBtn" class="header-settings-btn" title="Edit Toolboard">&#9881;</button>
            <span id="toolboardVersion" class="toolboard-version"></span>
        </div>
        <div class="header-controls">
            <button id="darkModeToggle" class="header-settings-btn" title="Toggle Dark Mode">&#9790;</button>
            <div class="board-selector-wrapper">
                <select id="boardSelector"></select>
            </div>
            <button id="addNoteBtn">+ Add Note</button>
            <button id="deleteBoardBtn">Delete Board</button>
            <button id="importExportBtn">Import/Export</button>
        </div>
        <div id="noteboardSettings" class="noteboard-settings">
            <label>Board Title</label>
            <input type="text" id="noteboardTitleInput" placeholder="Board title">
            <label>Header Color</label>
            <div class="color-picker-row" id="noteboardColorPicker"></div>
        </div>
    </header>

    <!-- Import/Export Modal -->
    <div id="importExportModal" class="import-export-modal">
        <div class="import-export-content">
            <span class="import-export-close">&times;</span>
            <h2>Import / Export</h2>

            <div class="import-export-tabs">
                <button class="import-export-tab active" data-tab="export">Export</button>
                <button class="import-export-tab" data-tab="import">Import</button>
                <button class="import-export-tab" data-tab="restore">Restore</button>
            </div>

            <!-- Export Note -->
            <div id="exportNote" class="import-export-note active">
                <h3>Export Notes</h3>
                <div id="exportNotesList" class="checkbox-list"></div>
                <button id="exportSelectedNotes" class="export-btn">Export Selected Notes</button>

                <h3 style="margin-top: 15px;">Export Boards</h3>
                <div id="exportBoardsList" class="checkbox-list"></div>
                <button id="exportSelectedBoards" class="export-btn">Export Selected Boards</button>

                <h3 style="margin-top: 15px;">Export Current Board View</h3>
                <p style="color: #7f8c8d; margin-bottom: 10px; font-size: 12px;">Export the current board as a standalone file.</p>
                <div style="display: flex; gap: 10px;">
                    <button id="exportBoardAsHTML" class="export-btn">Export as HTML</button>
                    <button id="exportBoardAsPNG" class="export-btn">Export as PNG</button>
                </div>
            </div>

            <!-- Import Note -->
            <div id="importNote" class="import-export-note">
                <h3>Import from File</h3>
                <input type="file" id="importFileInput" class="import-file-input" accept=".json">

                <h3>Or Paste JSON</h3>
                <textarea id="importTextarea" class="import-textarea" placeholder="Paste JSON data here..."></textarea>

                <button id="importDataBtn" class="import-btn">Import Data</button>
                <div id="importResult"></div>
            </div>

            <!-- Restore Note -->
            <div id="restoreNote" class="import-export-note">
                <h3>Restore Hidden Notes</h3>
                <p style="color: #7f8c8d; margin-bottom: 10px; font-size: 12px;">These built-in notes have been hidden. Select notes to restore them to your board.</p>
                <div id="hiddenNotesList" class="checkbox-list"></div>
                <button id="restoreSelectedNotes" class="import-btn">Restore Selected</button>
                <div id="restoreResult"></div>
            </div>
        </div>
    </div>

    <!-- Fullscreen backdrop -->
    <div id="fullscreenBackdrop" class="fullscreen-backdrop"></div>

    <main id="noteboard">
        <!-- Notes will be dynamically generated -->
    </main>

    <!-- Content Editor Modal -->
    <div id="contentEditorOverlay" class="content-editor-overlay">
        <div class="content-editor">
            <div class="content-editor-header">
                <h3>Edit Content: <span id="editorNoteTitle"></span></h3>
                <button class="content-editor-close">&times;</button>
            </div>
            <div class="content-editor-body">
                <div class="content-editor-input">
                    <div class="content-editor-label">Markdown</div>
                    <textarea class="content-editor-textarea" id="contentEditorTextarea" placeholder="Enter markdown content..."></textarea>
                </div>
                <div class="content-editor-resizer" id="editorResizer"></div>
                <div class="content-editor-preview">
                    <div class="content-editor-label">Preview</div>
                    <div class="content-editor-preview-area markdown-content" id="contentEditorPreview"></div>
                </div>
            </div>
            <div class="content-editor-footer">
                <button class="content-editor-reset">Reset to Default</button>
                <button class="content-editor-cancel">Cancel</button>
                <button class="content-editor-save">Save</button>
            </div>
            <div class="content-editor-resize content-editor-resize-e" data-resize="e"></div>
            <div class="content-editor-resize content-editor-resize-s" data-resize="s"></div>
            <div class="content-editor-resize content-editor-resize-se" data-resize="se"></div>
        </div>
    </div>

    <!-- Feature Selection Modal -->
    <div id="featureSelectModal" class="feature-select-modal">
        <div class="feature-select-content">
            <span class="feature-select-close">&times;</span>
            <h2>Choose Note Type</h2>
            <div id="featureSelectList" class="feature-select-list"></div>
        </div>
    </div>

    <!-- Note Settings Modal -->
    <div id="noteSettingsOverlay" class="note-settings-overlay">
        <div class="note-settings">
            <div class="note-settings-header">
                <h3>Note Settings</h3>
                <button class="note-settings-close">&times;</button>
            </div>
            <label>Title</label>
            <input type="text" id="noteSettingsTitleInput" class="title-input" placeholder="Note title">
            <label>Color</label>
            <div class="color-picker-row" id="noteSettingsColorPicker"></div>
            <button class="edit-content-btn" id="noteSettingsEditBtn">Edit Content</button>
            <button class="duplicate-note-btn" id="noteSettingsDuplicateBtn">Duplicate Note</button>
            <button class="export-note-btn" id="noteSettingsExportBtn">Export as HTML</button>
            <button class="export-png-btn" id="noteSettingsExportPngBtn">Export as PNG</button>
            <button class="delete-note-btn" id="noteSettingsDeleteBtn">Hide Note</button>
        </div>
    </div>

    <script>
// Default variables - empty for generic noteboard, import a board to add data
const DEFAULT_VARIABLES = {};

// Built-in notes - empty for generic noteboard, import notes/boards to add
const SECTIONS = [];

// Generate default positions (empty for generic noteboard)
function generateDefaultPositions() {
    return {};
}

const DEFAULT_POSITIONS = generateDefaultPositions();

// Note templates for feature selection
const NOTE_TEMPLATES = {
    'blank': {
        id: 'blank',
        name: 'Blank Note',
        description: 'Start with an empty note',
        icon: '📝',
        title: 'New Note',
        content: ''
    },
    'dynamic-investment-calculator': {
        id: 'dynamic-investment-calculator',
        name: 'Investment Growth Calculator',
        description: 'Interactive calculator with inputs for initial amount, monthly contribution, rate, and years',
        icon: '📈',
        title: 'Investment Growth Calculator',
        content: `<div style="background:#f8f9fa;padding:15px;border-radius:6px;">
<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:15px;">
<div>
<label style="display:block;font-size:11px;color:#666;margin-bottom:4px;">Initial Investment</label>
<input type="number" id="growthInitial" value="10000" oninput="calculateGrowth()" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px;">
</div>
<div>
<label style="display:block;font-size:11px;color:#666;margin-bottom:4px;">Monthly Contribution</label>
<input type="number" id="growthMonthly" value="500" oninput="calculateGrowth()" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px;">
</div>
<div>
<label style="display:block;font-size:11px;color:#666;margin-bottom:4px;">Annual Return (%)</label>
<input type="number" id="growthRate" value="7" step="0.1" oninput="calculateGrowth()" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px;">
</div>
<div>
<label style="display:block;font-size:11px;color:#666;margin-bottom:4px;">Years</label>
<input type="number" id="growthYears" value="30" oninput="calculateGrowth()" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px;">
</div>
</div>
<div style="margin-bottom:15px;">
<label style="display:block;font-size:11px;color:#666;margin-bottom:4px;">Compounding</label>
<div style="display:flex;gap:0;border:1px solid #ddd;border-radius:4px;overflow:hidden;">
<label style="flex:1;margin:0;"><input type="radio" name="growthCompound" value="monthly" checked onchange="calculateGrowth()" style="display:none;"><span id="compoundMonthlyBtn" style="display:block;padding:8px;text-align:center;cursor:pointer;background:#3498db;color:white;font-size:12px;">Monthly</span></label>
<label style="flex:1;margin:0;"><input type="radio" name="growthCompound" value="annual" onchange="calculateGrowth()" style="display:none;"><span id="compoundAnnualBtn" style="display:block;padding:8px;text-align:center;cursor:pointer;background:white;color:#333;font-size:12px;">Annual</span></label>
</div>
</div>
<div id="growthResults"></div>
</div>`,
        onInit: 'calculateGrowth'
    },
    'simple-calculator': {
        id: 'simple-calculator',
        name: 'Simple Calculator',
        description: 'Basic arithmetic calculator for quick math',
        icon: '🔢',
        title: 'Calculator',
        content: `<div style="background:#2c3e50;padding:15px;border-radius:8px;max-width:240px;">
<input type="text" id="calcDisplay" value="0" readonly style="width:100%;padding:12px;font-size:24px;text-align:right;border:none;border-radius:4px;margin-bottom:10px;background:#ecf0f1;font-family:monospace;">
<div style="display:grid;grid-template-columns:repeat(4,1fr);gap:8px;">
<button onclick="calcClear()" style="grid-column:span 2;padding:15px;font-size:16px;border:none;border-radius:4px;background:#e74c3c;color:white;cursor:pointer;">C</button>
<button onclick="calcBackspace()" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#95a5a6;color:white;cursor:pointer;">⌫</button>
<button onclick="calcOp('/')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#3498db;color:white;cursor:pointer;">÷</button>
<button onclick="calcNum('7')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">7</button>
<button onclick="calcNum('8')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">8</button>
<button onclick="calcNum('9')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">9</button>
<button onclick="calcOp('*')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#3498db;color:white;cursor:pointer;">×</button>
<button onclick="calcNum('4')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">4</button>
<button onclick="calcNum('5')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">5</button>
<button onclick="calcNum('6')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">6</button>
<button onclick="calcOp('-')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#3498db;color:white;cursor:pointer;">−</button>
<button onclick="calcNum('1')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">1</button>
<button onclick="calcNum('2')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">2</button>
<button onclick="calcNum('3')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">3</button>
<button onclick="calcOp('+')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#3498db;color:white;cursor:pointer;">+</button>
<button onclick="calcNum('0')" style="grid-column:span 2;padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">0</button>
<button onclick="calcNum('.')" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#ecf0f1;cursor:pointer;">.</button>
<button onclick="calcEquals()" style="padding:15px;font-size:16px;border:none;border-radius:4px;background:#27ae60;color:white;cursor:pointer;">=</button>
</div>
</div>`,
        onInit: 'calcInit'
    },
    'dynamic-tax-calculator': {
        id: 'dynamic-tax-calculator',
        name: 'Tax Calculator',
        description: 'Interactive calculator for estimating federal income tax',
        icon: '🧾',
        title: 'Tax Calculator',
        content: `<div style="background:#f8f9fa;padding:15px;border-radius:6px;">
<div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:15px;">
<div>
<label style="display:block;font-size:11px;color:#666;margin-bottom:4px;">Annual Income</label>
<input type="number" id="taxIncome" value="75000" oninput="calculateTax()" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px;">
</div>
<div>
<label style="display:block;font-size:11px;color:#666;margin-bottom:4px;">Filing Status</label>
<select id="taxStatus" onchange="calculateTax()" style="width:100%;padding:8px;border:1px solid #ddd;border-radius:4px;font-size:14px;background:white;">
<option value="single">Single</option>
<option value="married">Married Filing Jointly</option>
</select>
</div>
</div>
<div id="taxResults"></div>
</div>`,
        onInit: 'calculateTax'
    },
    'checklist': {
        id: 'checklist',
        name: 'Checklist',
        description: 'Interactive checklist with add, check, and delete functionality',
        icon: '✅',
        title: 'Checklist',
        content: `<div class="checklist-widget" style="padding:10px;">
<div style="display:flex;gap:8px;margin-bottom:12px;">
<input type="text" class="checklist-input" placeholder="Add new item..." style="flex:1;padding:8px 10px;border:1px solid var(--border-color);border-radius:4px;font-size:13px;background:var(--input-bg);color:var(--text-primary);">
<button onclick="checklistAddItem(this)" style="padding:8px 14px;background:#27ae60;color:white;border:none;border-radius:4px;cursor:pointer;font-size:13px;">Add</button>
</div>
<ul class="checklist-items" style="list-style:none;padding:0;margin:0;"></ul>
<div class="checklist-summary" style="margin-top:12px;padding-top:10px;border-top:1px solid var(--border-light);font-size:11px;color:var(--text-muted);"></div>
</div>`,
        onInit: 'checklistInit'
    },
    'calendar': {
        id: 'calendar',
        name: 'Calendar',
        description: 'Year view calendar with .ics import and event tracking',
        icon: '📅',
        title: 'Calendar ' + new Date().getFullYear(),
        content: `<div class="calendar-widget">
<div class="calendar-header">
<div class="calendar-year-nav">
<button onclick="calendarPrevYear(this)">&lt;</button>
<span class="calendar-year-display">${new Date().getFullYear()}</span>
<button onclick="calendarNextYear(this)">&gt;</button>
</div>
<button class="calendar-manage-btn" onclick="calendarOpenManage(this)">Manage Calendars</button>
</div>
<div class="calendar-year-grid"></div>
<div class="calendar-legend"></div>
</div>`,
        onInit: 'calendarInit'
    },
    'diff-viewer': {
        id: 'diff-viewer',
        name: 'Diff Viewer',
        description: 'Compare two texts with visual diff highlighting',
        icon: '🔀',
        title: 'Text Diff',
        content: `<div class="diff-widget">
<div class="diff-toolbar">
<div class="diff-mode-toggle">
<button class="diff-mode-btn active" onclick="diffSetMode(this, 'edit')">Edit</button>
<button class="diff-mode-btn" onclick="diffSetMode(this, 'view')">View</button>
</div>
<div class="diff-view-options">
<button class="diff-view-btn active" onclick="diffSetView(this, 'split')">Split</button>
<button class="diff-view-btn" onclick="diffSetView(this, 'unified')">Unified</button>
<label class="diff-whitespace-toggle">
<input type="checkbox" onchange="diffToggleWhitespace(this)">
Hide Whitespace
</label>
</div>
</div>
<div class="diff-edit-container">
<div class="diff-edit-pane">
<label>Original</label>
<textarea placeholder="Enter original text..." oninput="diffOnInput(this, 'original')" onscroll="diffSyncScroll(this, 'original')"></textarea>
</div>
<div class="diff-edit-resizer"></div>
<div class="diff-edit-pane">
<label>Modified</label>
<textarea placeholder="Enter modified text..." oninput="diffOnInput(this, 'modified')" onscroll="diffSyncScroll(this, 'modified')"></textarea>
</div>
</div>
<div class="diff-view-container">
<div class="diff-output"></div>
</div>
<div class="diff-stats"></div>
</div>`,
        onInit: 'diffInit'
    },
    'sequence-diagram': {
        id: 'sequence-diagram',
        name: 'Sequence Diagram',
        description: 'Create sequence diagrams from simple text notation',
        icon: '📊',
        title: 'Sequence Diagram',
        content: `<div class="seq-widget">
<div class="seq-toolbar">
<div class="seq-mode-toggle">
<button class="seq-mode-btn" onclick="seqSetMode(this, 'edit')">Edit</button>
<button class="seq-mode-btn active" onclick="seqSetMode(this, 'split')">Split</button>
<button class="seq-mode-btn" onclick="seqSetMode(this, 'view')">View</button>
</div>
<button class="seq-help-btn" onclick="seqShowHelp(this)">? Syntax Help</button>
</div>
<div class="seq-edit-container">
<textarea placeholder="Enter sequence diagram notation..." oninput="seqOnInput(this)"></textarea>
</div>
<div class="seq-split-container active">
<div class="seq-edit-pane">
<textarea placeholder="Enter sequence diagram notation...

Example:
Alice -> Bob: Hello
Bob --> Alice: Hi there!
Bob -> Charlie: Forward
Charlie --> Bob: Reply" oninput="seqOnInput(this)"></textarea>
</div>
<div class="seq-split-resizer"></div>
<div class="seq-view-pane">
<div class="seq-diagram"></div>
</div>
</div>
<div class="seq-view-container">
<div class="seq-diagram"></div>
</div>
<div class="seq-help-text">
<code>A -> B: msg</code> | <code>Note over A: text</code> | Colors: <code>[red]</code> or <code>[line:red, text:blue]</code>
</div>
</div>`,
        onInit: 'seqInit'
    }
};

// Board management
function loadBoards() {
    const stored = localStorage.getItem('financeBoards');
    if (stored) {
        try {
            return JSON.parse(stored);
        } catch (e) {
            return [{ id: 'default', name: 'Toolboard' }];
        }
    }
    return [{ id: 'default', name: 'Toolboard' }];
}

function saveBoards(boards) {
    localStorage.setItem('financeBoards', JSON.stringify(boards));
}

function getCurrentBoardId() {
    return localStorage.getItem('financeCurrentBoard') || 'default';
}

function setCurrentBoardId(boardId) {
    localStorage.setItem('financeCurrentBoard', boardId);
}

let boards = loadBoards();
let currentBoardId = getCurrentBoardId();

// Migrate old data to new board-specific format (one-time migration)
function migrateOldData() {
    // Check if migration already done
    if (localStorage.getItem('financeMigrationDone')) return;

    // Map of old keys to new key suffixes
    const migrations = {
        'financeVariables': 'variables',
        'financeNotePositions': 'positions',
        'financeNoteCustomizations': 'noteCustomizations',
        'financeCustomNotes': 'customNotes',
        'financeNoteboardSettings': 'noteboardSettings'
    };

    let hadOldData = false;
    for (const [oldKey, newSuffix] of Object.entries(migrations)) {
        const oldData = localStorage.getItem(oldKey);
        if (oldData) {
            hadOldData = true;
            // Copy to default board
            localStorage.setItem(`finance_default_${newSuffix}`, oldData);
            // Remove old key
            localStorage.removeItem(oldKey);
        }
    }

    if (hadOldData) {
        console.log('Migrated old data to default board');
    }

    localStorage.setItem('financeMigrationDone', 'true');
}

migrateOldData();

// Helper to get board-specific storage key
function boardKey(key) {
    return `finance_${currentBoardId}_${key}`;
}

// Load variables from localStorage or use defaults
function loadVariables() {
    const stored = localStorage.getItem(boardKey('variables'));
    if (stored) {
        try {
            return JSON.parse(stored);
        } catch (e) {
            console.error('Error parsing stored variables:', e);
            return DEFAULT_VARIABLES;
        }
    }
    return DEFAULT_VARIABLES;
}

// Save variables to localStorage
function saveVariables(variables) {
    localStorage.setItem(boardKey('variables'), JSON.stringify(variables));
}

// Load note positions from localStorage or use defaults
function loadPositions() {
    const stored = localStorage.getItem(boardKey('positions'));
    if (stored) {
        try {
            return JSON.parse(stored);
        } catch (e) {
            console.error('Error parsing stored positions:', e);
            return { ...DEFAULT_POSITIONS };
        }
    }
    return { ...DEFAULT_POSITIONS };
}

// Save note positions to localStorage
function savePositions(positions) {
    localStorage.setItem(boardKey('positions'), JSON.stringify(positions));
}

// Reset everything
function resetVariables() {
    localStorage.removeItem(boardKey('variables'));
    return DEFAULT_VARIABLES;
}

function resetPositions() {
    localStorage.removeItem(boardKey('positions'));
    return { ...generateDefaultPositions() };
}

// Helper functions for calculations
function formatCurrency(amount) {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
    }).format(amount);
}

function formatNumber(num) {
    return new Intl.NumberFormat('en-US').format(Math.round(num));
}

// Main application
let variables = loadVariables();
let positions = loadPositions();
let maxZ = Math.max(...Object.values(positions).map(p => p.z || 1), 1);

// Snap threshold in pixels
const SNAP_THRESHOLD = 15;

// Drag state
let dragState = {
    isDragging: false,
    note: null,
    startX: 0,
    startY: 0,
    offsetX: 0,
    offsetY: 0
};

// Resize state
let resizeState = {
    isResizing: false,
    note: null,
    handle: null,
    startX: 0,
    startY: 0,
    startWidth: 0,
    startHeight: 0,
    startLeft: 0,
    startTop: 0
};

// Dark mode setup
function setupDarkMode() {
    const toggle = document.getElementById('darkModeToggle');
    const stored = localStorage.getItem('toolboard_darkMode');

    // Apply stored preference or check system preference
    if (stored === 'true' || (stored === null && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.body.classList.add('dark-mode');
        toggle.innerHTML = '&#9788;'; // Sun icon for light mode
        toggle.title = 'Switch to Light Mode';
    }

    toggle.addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
        const isDark = document.body.classList.contains('dark-mode');
        localStorage.setItem('toolboard_darkMode', isDark);
        toggle.innerHTML = isDark ? '&#9788;' : '&#9790;'; // Sun or Moon
        toggle.title = isDark ? 'Switch to Light Mode' : 'Switch to Dark Mode';
    });
}

// Initialize the noteboard
function init() {
    setupDarkMode();
    populateBoardSelector();
    applyNoteboardSettings();
    setupNoteboardSettings();
    renderNoteboard();
    setupDragging();
    setupResizing();
    setupNoteControls();
    setupContentEditor();
    setupButtons();
    setupImportExport();
    setupFeatureSelect();
    displayVersion();
}

// Display Toolboard version based on file modification date
function displayVersion() {
    const versionEl = document.getElementById('toolboardVersion');
    if (versionEl) {
        const lastMod = new Date(document.lastModified);
        const version = lastMod.toISOString().slice(0, 10).replace(/-/g, '.');
        versionEl.textContent = 'v' + version;
        versionEl.title = 'Toolboard version (last modified: ' + lastMod.toLocaleString() + ')';
    }
}

// Setup note minimize and settings controls
let currentSettingsNoteId = null;

function setupNoteControls() {
    const noteboard = document.getElementById('noteboard');
    const settingsOverlay = document.getElementById('noteSettingsOverlay');
    const settingsTitleInput = document.getElementById('noteSettingsTitleInput');
    const settingsColorPicker = document.getElementById('noteSettingsColorPicker');
    const settingsEditBtn = document.getElementById('noteSettingsEditBtn');
    const settingsDuplicateBtn = document.getElementById('noteSettingsDuplicateBtn');
    const settingsExportBtn = document.getElementById('noteSettingsExportBtn');
    const settingsExportPngBtn = document.getElementById('noteSettingsExportPngBtn');
    const settingsDeleteBtn = document.getElementById('noteSettingsDeleteBtn');
    const settingsCloseBtn = settingsOverlay.querySelector('.note-settings-close');

    // Populate color picker
    settingsColorPicker.innerHTML = HEADER_COLORS.map(c =>
        `<div class="color-swatch" style="background: ${c}" data-color="${c}"></div>`
    ).join('');

    // Minimize button
    noteboard.addEventListener('click', (e) => {
        if (e.target.closest('.minimize-btn')) {
            e.stopPropagation();
            const note = e.target.closest('.note');
            const noteId = note.getAttribute('data-note');
            const btn = e.target.closest('.minimize-btn');

            note.classList.toggle('minimized');
            btn.classList.toggle('minimized');

            // Save state
            noteCustomizations[noteId] = noteCustomizations[noteId] || {};
            noteCustomizations[noteId].minimized = note.classList.contains('minimized');
            saveNoteCustomizations(noteCustomizations);
        }
    });

    // Fullscreen button
    const fullscreenBackdrop = document.getElementById('fullscreenBackdrop');
    let currentFullscreenNote = null;

    function exitFullscreen() {
        if (currentFullscreenNote) {
            currentFullscreenNote.classList.remove('fullscreen');
            const btn = currentFullscreenNote.querySelector('.fullscreen-btn');
            if (btn) btn.classList.remove('active');
            fullscreenBackdrop.classList.remove('active');
            currentFullscreenNote = null;
        }
    }

    noteboard.addEventListener('click', (e) => {
        if (e.target.closest('.fullscreen-btn')) {
            e.stopPropagation();
            const note = e.target.closest('.note');
            const btn = e.target.closest('.fullscreen-btn');

            if (note.classList.contains('fullscreen')) {
                exitFullscreen();
            } else {
                // Exit any existing fullscreen first
                exitFullscreen();
                note.classList.add('fullscreen');
                btn.classList.add('active');
                fullscreenBackdrop.classList.add('active');
                currentFullscreenNote = note;
            }
        }
    });

    // Click backdrop to exit fullscreen
    fullscreenBackdrop.addEventListener('click', exitFullscreen);

    // ESC key to exit fullscreen
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && currentFullscreenNote) {
            exitFullscreen();
        }
    });

    // Settings button - open modal
    noteboard.addEventListener('click', (e) => {
        if (e.target.closest('.settings-btn')) {
            e.stopPropagation();
            const note = e.target.closest('.note');
            const noteId = note.getAttribute('data-note');
            currentSettingsNoteId = noteId;

            // Bring note to front
            let highestZ = 0;
            document.querySelectorAll('.note').forEach(s => {
                const z = parseInt(s.style.zIndex) || 0;
                if (z > highestZ) highestZ = z;
            });
            maxZ = highestZ + 1;
            note.style.zIndex = maxZ;
            positions[noteId] = positions[noteId] || {};
            positions[noteId].z = maxZ;

            // Populate modal with current note settings
            const custom = noteCustomizations[noteId] || {};
            const content = getNoteContent(noteId);
            const displayTitle = custom.title || content.title;
            const headerColor = custom.color || null;
            const isCustomNote = customNotes.includes(noteId);

            settingsTitleInput.value = displayTitle;
            settingsDeleteBtn.textContent = isCustomNote ? 'Delete Note' : 'Hide Note';

            // Update color picker selection
            settingsColorPicker.querySelectorAll('.color-swatch').forEach(s => {
                s.classList.toggle('selected', s.getAttribute('data-color') === headerColor);
            });

            // Open modal
            settingsOverlay.classList.add('open');
        }
    });

    // Close modal
    function closeSettingsModal() {
        settingsOverlay.classList.remove('open');
        currentSettingsNoteId = null;
    }

    settingsCloseBtn.addEventListener('click', closeSettingsModal);

    // Close on overlay background click
    settingsOverlay.addEventListener('click', (e) => {
        if (e.target === settingsOverlay) {
            closeSettingsModal();
        }
    });

    // Color swatch click in modal
    settingsColorPicker.addEventListener('click', (e) => {
        if (e.target.classList.contains('color-swatch') && currentSettingsNoteId) {
            e.stopPropagation();
            const noteId = currentSettingsNoteId;
            const note = document.querySelector(`.note[data-note="${noteId}"]`);
            const color = e.target.getAttribute('data-color');
            const header = note.querySelector('.note-header');

            // Update UI
            header.style.background = color;
            settingsColorPicker.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
            e.target.classList.add('selected');

            // Save
            noteCustomizations[noteId] = noteCustomizations[noteId] || {};
            noteCustomizations[noteId].color = color;
            saveNoteCustomizations(noteCustomizations);
        }
    });

    // Title input change in modal
    settingsTitleInput.addEventListener('input', (e) => {
        if (currentSettingsNoteId) {
            const noteId = currentSettingsNoteId;
            const note = document.querySelector(`.note[data-note="${noteId}"]`);
            const titleSpan = note.querySelector('.note-title');
            const newTitle = e.target.value;

            // Update UI
            titleSpan.textContent = newTitle;

            // Save
            noteCustomizations[noteId] = noteCustomizations[noteId] || {};
            noteCustomizations[noteId].title = newTitle;
            saveNoteCustomizations(noteCustomizations);
        }
    });

    // Edit content button in modal
    settingsEditBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentSettingsNoteId) {
            const noteId = currentSettingsNoteId;
            closeSettingsModal();
            openContentEditor(noteId);
        }
    });

    // Duplicate note button in modal
    settingsDuplicateBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentSettingsNoteId) {
            const noteId = currentSettingsNoteId;
            closeSettingsModal();
            duplicateNote(noteId);
        }
    });

    // Export note button in modal
    settingsExportBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentSettingsNoteId) {
            const noteId = currentSettingsNoteId;
            closeSettingsModal();
            exportNoteAsHtml(noteId);
        }
    });

    // Export note as PNG button in modal
    settingsExportPngBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentSettingsNoteId) {
            const noteId = currentSettingsNoteId;
            closeSettingsModal();
            exportNoteAsPng(noteId);
        }
    });

    // Delete note button in modal
    settingsDeleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentSettingsNoteId) {
            const noteId = currentSettingsNoteId;
            closeSettingsModal();
            deleteNote(noteId);
        }
    });

    // Prevent dragging when interacting with header buttons
    noteboard.addEventListener('mousedown', (e) => {
        if (e.target.closest('.header-btn')) {
            e.stopPropagation();
        }
    });
}

// Render all notes
function renderNoteboard() {
    const noteboard = document.getElementById('noteboard');
    noteboard.innerHTML = '';

    const notesToAutoFit = [];

    // Render built-in notes (excluding hidden ones)
    SECTIONS.forEach(noteId => {
        if (hiddenNotes.includes(noteId)) return;
        const note = createNote(noteId);
        if (note) {
            noteboard.appendChild(note);
            // Check if note needs auto-fitting (no saved dimensions and has content)
            const pos = positions[noteId];
            const custom = noteCustomizations[noteId] || {};
            if ((!pos || (!pos.width && !pos.height)) && custom.customContent) {
                notesToAutoFit.push(note);
            }
        }
    });

    // Render custom notes
    customNotes.forEach(noteId => {
        const note = createNote(noteId);
        if (note) {
            noteboard.appendChild(note);
            // Check if note needs auto-fitting (no saved dimensions)
            const pos = positions[noteId];
            const custom = noteCustomizations[noteId] || {};
            if ((!pos || (!pos.width && !pos.height)) && (custom.customContent || custom.templateId)) {
                notesToAutoFit.push(note);
            }
        }
    });

    // Initialize dynamic calculators if present
    initializeCalculators();

    // Auto-fit notes after DOM is ready
    if (notesToAutoFit.length > 0) {
        requestAnimationFrame(() => {
            notesToAutoFit.forEach(note => autoFitNoteContent(note, true));
        });
    }
}

function initializeCalculators() {
    // Small delay to ensure DOM is ready
    setTimeout(() => {
        if (document.getElementById('taxIncome')) calculateTax();
        if (document.getElementById('growthInitial')) calculateGrowth();
        if (document.querySelector('.checklist-widget')) checklistInit();
        if (document.querySelector('.calendar-widget')) calendarInit();
        if (document.querySelector('.diff-widget')) diffInit();
        if (document.querySelector('.seq-widget')) seqInit();
    }, 50);
}

// Dynamic Calculator Functions
const taxBrackets = {
    single: [
        {min: 0, max: 12400, rate: 0.10},
        {min: 12400, max: 50400, rate: 0.12},
        {min: 50400, max: 105700, rate: 0.22},
        {min: 105700, max: 201775, rate: 0.24},
        {min: 201775, max: 256225, rate: 0.32},
        {min: 256225, max: 640800, rate: 0.35},
        {min: 640800, max: Infinity, rate: 0.37}
    ],
    married: [
        {min: 0, max: 24800, rate: 0.10},
        {min: 24800, max: 100800, rate: 0.12},
        {min: 100800, max: 211400, rate: 0.22},
        {min: 211400, max: 403550, rate: 0.24},
        {min: 403550, max: 512450, rate: 0.32},
        {min: 512450, max: 788700, rate: 0.35},
        {min: 788700, max: Infinity, rate: 0.37}
    ]
};
const stdDeductions = {single: 16100, married: 32200};

function calculateTax() {
    const incomeEl = document.getElementById('taxIncome');
    const statusEl = document.getElementById('taxStatus');
    const resultsEl = document.getElementById('taxResults');
    if (!incomeEl || !statusEl || !resultsEl) return;

    const income = parseFloat(incomeEl.value) || 0;
    const status = statusEl.value;
    const ded = stdDeductions[status];
    const taxable = Math.max(0, income - ded);
    let totalTax = 0;
    let breakdown = '';

    for (const b of taxBrackets[status]) {
        if (taxable > b.min) {
            const amt = Math.min(taxable, b.max) - b.min;
            const tax = amt * b.rate;
            totalTax += tax;
            if (amt > 0) {
                breakdown += `<div style="display:flex;justify-content:space-between;padding:4px 0;border-bottom:1px solid #eee;"><span>${(b.rate*100)}%</span><span>$${amt.toLocaleString()}</span><span style="color:#c0392b">$${tax.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0})}</span></div>`;
            }
        }
    }

    const effRate = income > 0 ? (totalTax / income * 100).toFixed(1) : 0;
    const margBracket = taxBrackets[status].find(b => taxable >= b.min && taxable < b.max);
    const margRate = margBracket ? margBracket.rate * 100 : 37;

    resultsEl.innerHTML = `
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:15px;">
            <div style="background:#fff;padding:10px;border-radius:4px;text-align:center;">
                <div style="font-size:12px;color:#7f8c8d;">Standard Deduction</div>
                <div style="font-size:18px;font-weight:600;color:#27ae60;">$${ded.toLocaleString()}</div>
            </div>
            <div style="background:#fff;padding:10px;border-radius:4px;text-align:center;">
                <div style="font-size:12px;color:#7f8c8d;">Taxable Income</div>
                <div style="font-size:18px;font-weight:600;">$${taxable.toLocaleString()}</div>
            </div>
            <div style="background:#fff;padding:10px;border-radius:4px;text-align:center;">
                <div style="font-size:12px;color:#7f8c8d;">Total Tax</div>
                <div style="font-size:18px;font-weight:600;color:#c0392b;">$${totalTax.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0})}</div>
            </div>
            <div style="background:#fff;padding:10px;border-radius:4px;text-align:center;">
                <div style="font-size:12px;color:#7f8c8d;">Effective / Marginal</div>
                <div style="font-size:18px;font-weight:600;">${effRate}% / ${margRate}%</div>
            </div>
        </div>
        <div style="font-size:12px;font-weight:600;margin-bottom:8px;color:#7f8c8d;">TAX BY BRACKET</div>
        ${breakdown}
        <div style="display:flex;justify-content:space-between;padding:8px 0;font-weight:600;">
            <span>Take Home (Monthly)</span>
            <span style="color:#27ae60;">$${((income - totalTax) / 12).toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0})}</span>
        </div>
    `;
}

// Checklist Widget Functions
let checklistDragState = { dragging: null, noteId: null, parentIdx: null };

function checklistGetNoteId(element) {
    const note = element.closest('.note');
    return note ? note.getAttribute('data-note') : null;
}

function checklistGetData(noteId) {
    const custom = noteCustomizations[noteId] || {};
    // Migrate old format: convert completed boolean to status
    let items = custom.checklistItems || [];
    items = items.map(item => {
        if (typeof item.completed === 'boolean' && !item.status) {
            return { ...item, status: item.completed ? 'completed' : 'pending', children: item.children || [] };
        }
        return { ...item, children: item.children || [] };
    });
    return items;
}

function checklistSaveData(noteId, items) {
    noteCustomizations[noteId] = noteCustomizations[noteId] || {};
    noteCustomizations[noteId].checklistItems = items;
    saveNoteCustomizations(noteCustomizations);
}

function checklistInit() {
    document.querySelectorAll('.checklist-widget').forEach(widget => {
        const noteId = checklistGetNoteId(widget);
        if (noteId) {
            checklistRender(widget, noteId);
        }
    });
}

function checklistRenderItem(item, idx, parentIdx = null) {
    const statusClass = item.status || 'pending';
    const path = parentIdx !== null ? `${parentIdx}.${idx}` : `${idx}`;
    const isSubitem = parentIdx !== null;

    let childrenHtml = '';
    if (!isSubitem && item.children && item.children.length > 0) {
        childrenHtml = `<ul class="checklist-subitems">${item.children.map((child, cIdx) =>
            checklistRenderItem(child, cIdx, idx)
        ).join('')}</ul>`;
    }

    const addSubBtn = !isSubitem ? `<span class="checklist-add-sub" onclick="checklistAddSub(this, ${idx})">+ Add sub-item</span>` : '';

    return `
        <div class="checklist-item-wrapper" data-path="${path}">
            <li class="checklist-item ${statusClass}" data-path="${path}" draggable="true"
                ondragstart="checklistDragStart(event, '${path}')"
                ondragover="checklistDragOver(event)"
                ondragleave="checklistDragLeave(event)"
                ondrop="checklistDrop(event, '${path}')">
                <span class="checklist-drag">⋮⋮</span>
                <span class="checklist-status" onclick="checklistCycleStatus(this, '${path}')" title="Click to change status"></span>
                <span class="checklist-text" contenteditable="true"
                    onblur="checklistUpdateText(this, '${path}')"
                    onkeydown="checklistTextKeydown(event, this)">${escapeHtml(item.text)}</span>
                <span class="checklist-actions">
                    ${!isSubitem ? `<button class="checklist-btn" onclick="checklistAddSub(this, ${idx})" title="Add sub-item">+</button>` : ''}
                    <button class="checklist-btn delete" onclick="checklistDelete(this, '${path}')" title="Delete">×</button>
                </span>
            </li>
            ${childrenHtml}
            ${addSubBtn}
        </div>
    `;
}

function checklistRender(widget, noteId) {
    const items = checklistGetData(noteId);
    const listEl = widget.querySelector('.checklist-items');
    const summaryEl = widget.querySelector('.checklist-summary');

    if (!listEl) return;

    listEl.innerHTML = items.map((item, idx) => checklistRenderItem(item, idx)).join('');

    // Update summary with all items including children
    let total = 0, completed = 0, inProgress = 0;
    const countItems = (arr) => {
        arr.forEach(item => {
            total++;
            if (item.status === 'completed') completed++;
            else if (item.status === 'in_progress') inProgress++;
            if (item.children) countItems(item.children);
        });
    };
    countItems(items);

    if (total > 0) {
        let summary = `${completed}/${total} done`;
        if (inProgress > 0) summary += ` · ${inProgress} in progress`;
        summaryEl.textContent = summary;
    } else {
        summaryEl.textContent = 'No items yet';
    }
}

function checklistGetItemByPath(items, path) {
    const parts = path.split('.').map(Number);
    let item = items[parts[0]];
    if (parts.length > 1 && item && item.children) {
        item = item.children[parts[1]];
    }
    return item;
}

function checklistSetItemByPath(items, path, value) {
    const parts = path.split('.').map(Number);
    if (parts.length === 1) {
        if (value === null) {
            items.splice(parts[0], 1);
        } else {
            items[parts[0]] = value;
        }
    } else if (items[parts[0]] && items[parts[0]].children) {
        if (value === null) {
            items[parts[0]].children.splice(parts[1], 1);
        } else {
            items[parts[0]].children[parts[1]] = value;
        }
    }
}

function checklistAddItem(btn) {
    const widget = btn.closest('.checklist-widget');
    const input = widget.querySelector('.checklist-input');
    const noteId = checklistGetNoteId(widget);

    if (!noteId || !input.value.trim()) return;

    const items = checklistGetData(noteId);
    items.push({ text: input.value.trim(), status: 'pending', children: [] });
    checklistSaveData(noteId, items);

    input.value = '';
    checklistRender(widget, noteId);
}

function checklistAddSub(el, parentIdx) {
    const widget = el.closest('.checklist-widget');
    const noteId = checklistGetNoteId(widget);
    if (!noteId) return;

    const items = checklistGetData(noteId);
    if (!items[parentIdx].children) items[parentIdx].children = [];
    items[parentIdx].children.push({ text: 'New sub-item', status: 'pending' });
    checklistSaveData(noteId, items);
    checklistRender(widget, noteId);

    // Focus the new item for editing
    setTimeout(() => {
        const newItem = widget.querySelector(`[data-path="${parentIdx}.${items[parentIdx].children.length - 1}"] .checklist-text`);
        if (newItem) {
            newItem.focus();
            document.execCommand('selectAll', false, null);
        }
    }, 10);
}

function checklistCycleStatus(el, path) {
    const widget = el.closest('.checklist-widget');
    const noteId = checklistGetNoteId(widget);
    if (!noteId) return;

    const items = checklistGetData(noteId);
    const item = checklistGetItemByPath(items, path);
    if (!item) return;

    // Cycle: pending -> in_progress -> completed -> pending
    const cycle = { 'pending': 'in_progress', 'in_progress': 'completed', 'completed': 'pending' };
    item.status = cycle[item.status] || 'pending';

    checklistSaveData(noteId, items);
    checklistRender(widget, noteId);
}

function checklistUpdateText(el, path) {
    const widget = el.closest('.checklist-widget');
    const noteId = checklistGetNoteId(widget);
    if (!noteId) return;

    const items = checklistGetData(noteId);
    const item = checklistGetItemByPath(items, path);
    if (!item) return;

    const newText = el.textContent.trim();
    if (newText && newText !== item.text) {
        item.text = newText;
        checklistSaveData(noteId, items);
    } else if (!newText) {
        el.textContent = item.text; // Restore if empty
    }
}

function checklistTextKeydown(e, el) {
    if (e.key === 'Enter') {
        e.preventDefault();
        el.blur();
    } else if (e.key === 'Escape') {
        const widget = el.closest('.checklist-widget');
        const noteId = checklistGetNoteId(widget);
        const path = el.closest('.checklist-item').dataset.path;
        const items = checklistGetData(noteId);
        const item = checklistGetItemByPath(items, path);
        if (item) el.textContent = item.text;
        el.blur();
    }
}

function checklistDelete(btn, path) {
    const widget = btn.closest('.checklist-widget');
    const noteId = checklistGetNoteId(widget);
    if (!noteId) return;

    const items = checklistGetData(noteId);
    checklistSetItemByPath(items, path, null);
    checklistSaveData(noteId, items);
    checklistRender(widget, noteId);
}

// Drag and drop for reordering
function checklistDragStart(e, path) {
    const widget = e.target.closest('.checklist-widget');
    checklistDragState.dragging = path;
    checklistDragState.noteId = checklistGetNoteId(widget);
    checklistDragState.parentIdx = path.includes('.') ? parseInt(path.split('.')[0]) : null;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
}

function checklistDragOver(e) {
    e.preventDefault();
    const item = e.target.closest('.checklist-item');
    if (item && !item.classList.contains('dragging')) {
        item.classList.add('drag-over');
    }
}

function checklistDragLeave(e) {
    const item = e.target.closest('.checklist-item');
    if (item) item.classList.remove('drag-over');
}

function checklistDrop(e, targetPath) {
    e.preventDefault();
    const targetItem = e.target.closest('.checklist-item');
    if (targetItem) targetItem.classList.remove('drag-over');

    const sourcePath = checklistDragState.dragging;
    const noteId = checklistDragState.noteId;

    if (!sourcePath || !noteId || sourcePath === targetPath) {
        checklistDragState = { dragging: null, noteId: null, parentIdx: null };
        return;
    }

    // Only allow reordering within same level (both top-level or both same parent)
    const sourceParent = sourcePath.includes('.') ? sourcePath.split('.')[0] : null;
    const targetParent = targetPath.includes('.') ? targetPath.split('.')[0] : null;

    if (sourceParent !== targetParent) {
        checklistDragState = { dragging: null, noteId: null, parentIdx: null };
        return;
    }

    const items = checklistGetData(noteId);
    const sourceIdx = parseInt(sourcePath.split('.').pop());
    const targetIdx = parseInt(targetPath.split('.').pop());

    let arr = items;
    if (sourceParent !== null) {
        arr = items[parseInt(sourceParent)].children;
    }

    // Move item
    const [moved] = arr.splice(sourceIdx, 1);
    arr.splice(targetIdx > sourceIdx ? targetIdx : targetIdx, 0, moved);

    checklistSaveData(noteId, items);

    const widget = document.querySelector(`.note[data-note="${noteId}"] .checklist-widget`);
    if (widget) checklistRender(widget, noteId);

    checklistDragState = { dragging: null, noteId: null, parentIdx: null };
}

document.addEventListener('dragend', (e) => {
    document.querySelectorAll('.checklist-item.dragging').forEach(el => el.classList.remove('dragging'));
    document.querySelectorAll('.checklist-item.drag-over').forEach(el => el.classList.remove('drag-over'));
    checklistDragState = { dragging: null, noteId: null, parentIdx: null };
});

// Add enter key support for checklist input
document.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && e.target.classList.contains('checklist-input')) {
        e.preventDefault();
        const widget = e.target.closest('.checklist-widget');
        const addBtn = widget.querySelector('button[onclick*="checklistAddItem"]');
        if (addBtn) checklistAddItem(addBtn);
    }
});

// Simple Calculator State
let calcState = { current: '0', previous: '', operator: '', newNumber: true };

function calcInit() {
    calcState = { current: '0', previous: '', operator: '', newNumber: true };
    const display = document.getElementById('calcDisplay');
    if (display) {
        display.value = '0';
        // Add keyboard support
        display.removeAttribute('readonly');
        display.addEventListener('keydown', calcKeyHandler);
        display.addEventListener('input', calcInputHandler);
        display.focus();
    }
}

function calcKeyHandler(e) {
    const key = e.key;

    // Prevent default for keys we handle
    if (/^[0-9.]$/.test(key) || ['+', '-', '*', '/', 'Enter', 'Escape', 'Backspace', '='].includes(key)) {
        e.preventDefault();
    }

    if (/^[0-9.]$/.test(key)) {
        calcNum(key);
    } else if (['+', '-', '*', '/'].includes(key)) {
        calcOp(key);
    } else if (key === 'Enter' || key === '=') {
        calcEquals();
    } else if (key === 'Escape' || key === 'Delete') {
        calcClear();
    } else if (key === 'Backspace') {
        calcBackspace();
    }
}

function calcInputHandler(e) {
    // Reset display to current state (prevent direct typing)
    const display = document.getElementById('calcDisplay');
    if (display) display.value = calcState.current;
}

function calcNum(num) {
    const display = document.getElementById('calcDisplay');
    if (!display) return;

    if (calcState.newNumber) {
        calcState.current = (num === '.') ? '0.' : num;
        calcState.newNumber = false;
    } else {
        if (num === '.' && calcState.current.includes('.')) return;
        calcState.current += num;
    }
    display.value = calcState.current;
}

function calcOp(op) {
    const display = document.getElementById('calcDisplay');
    if (!display) return;

    if (calcState.operator && !calcState.newNumber) {
        calcEquals();
    }
    calcState.previous = calcState.current;
    calcState.operator = op;
    calcState.newNumber = true;
}

function calcEquals() {
    const display = document.getElementById('calcDisplay');
    if (!display || !calcState.operator) return;

    const prev = parseFloat(calcState.previous);
    const curr = parseFloat(calcState.current);
    let result;

    switch (calcState.operator) {
        case '+': result = prev + curr; break;
        case '-': result = prev - curr; break;
        case '*': result = prev * curr; break;
        case '/': result = curr !== 0 ? prev / curr : 'Error'; break;
        default: return;
    }

    calcState.current = typeof result === 'number' ? String(Math.round(result * 1e10) / 1e10) : result;
    calcState.operator = '';
    calcState.newNumber = true;
    display.value = calcState.current;
}

function calcClear() {
    calcInit();
}

function calcBackspace() {
    const display = document.getElementById('calcDisplay');
    if (!display) return;

    if (calcState.current.length > 1) {
        calcState.current = calcState.current.slice(0, -1);
    } else {
        calcState.current = '0';
        calcState.newNumber = true;
    }
    display.value = calcState.current;
}

function calculateGrowth() {
    const initialEl = document.getElementById('growthInitial');
    const monthlyEl = document.getElementById('growthMonthly');
    const rateEl = document.getElementById('growthRate');
    const yearsEl = document.getElementById('growthYears');
    const resultsEl = document.getElementById('growthResults');
    const compoundEl = document.querySelector('input[name="growthCompound"]:checked');
    const monthlyBtn = document.getElementById('compoundMonthlyBtn');
    const annualBtn = document.getElementById('compoundAnnualBtn');
    if (!initialEl || !monthlyEl || !rateEl || !yearsEl || !resultsEl) return;

    const initial = parseFloat(initialEl.value) || 0;
    const monthly = parseFloat(monthlyEl.value) || 0;
    const rate = (parseFloat(rateEl.value) || 0) / 100;
    const years = parseInt(yearsEl.value) || 0;
    const isMonthly = !compoundEl || compoundEl.value === 'monthly';

    // Update toggle button styles
    if (monthlyBtn && annualBtn) {
        monthlyBtn.style.background = isMonthly ? '#3498db' : 'white';
        monthlyBtn.style.color = isMonthly ? 'white' : '#333';
        annualBtn.style.background = isMonthly ? 'white' : '#3498db';
        annualBtn.style.color = isMonthly ? '#333' : 'white';
    }

    const months = years * 12;
    const totalContrib = initial + (monthly * months);

    let fv = initial;
    if (isMonthly) {
        // Monthly compounding
        const monthlyRate = rate / 12;
        for (let i = 0; i < months; i++) {
            fv = fv * (1 + monthlyRate) + monthly;
        }
    } else {
        // Annual compounding
        for (let i = 0; i < years; i++) {
            fv = fv * (1 + rate) + (monthly * 12);
        }
    }
    const growth = fv - totalContrib;

    // Calculate timeline milestones
    const milestones = [5, 10, 15, 20, 25, 30, 35, 40].filter(y => y <= years);
    let timeline = '';
    for (const y of milestones) {
        let val = initial;
        if (isMonthly) {
            const monthlyRate = rate / 12;
            for (let i = 0; i < y * 12; i++) val = val * (1 + monthlyRate) + monthly;
        } else {
            for (let i = 0; i < y; i++) val = val * (1 + rate) + (monthly * 12);
        }
        timeline += `<div style="display:flex;justify-content:space-between;padding:4px 0;border-bottom:1px solid #eee;"><span>${y} years</span><span style="color:#27ae60;font-weight:600;">$${val.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0})}</span></div>`;
    }

    resultsEl.innerHTML = `
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:15px;">
            <div style="background:#fff;padding:10px;border-radius:4px;text-align:center;">
                <div style="font-size:12px;color:#7f8c8d;">Future Value</div>
                <div style="font-size:20px;font-weight:700;color:#27ae60;">$${fv.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0})}</div>
            </div>
            <div style="background:#fff;padding:10px;border-radius:4px;text-align:center;">
                <div style="font-size:12px;color:#7f8c8d;">Total Contributions</div>
                <div style="font-size:20px;font-weight:600;">$${totalContrib.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0})}</div>
            </div>
            <div style="background:#fff;padding:10px;border-radius:4px;text-align:center;">
                <div style="font-size:12px;color:#7f8c8d;">Investment Growth</div>
                <div style="font-size:20px;font-weight:600;color:#27ae60;">$${growth.toLocaleString(undefined,{minimumFractionDigits:0,maximumFractionDigits:0})}</div>
            </div>
            <div style="background:#fff;padding:10px;border-radius:4px;text-align:center;">
                <div style="font-size:12px;color:#7f8c8d;">Growth Multiple</div>
                <div style="font-size:20px;font-weight:600;">${totalContrib > 0 ? (fv / totalContrib).toFixed(1) : '0.0'}x</div>
            </div>
        </div>
        ${timeline ? `<div style="font-size:12px;font-weight:600;margin-bottom:8px;color:#7f8c8d;">GROWTH TIMELINE</div>${timeline}` : ''}
    `;
}

// Calendar Widget
const CALENDAR_COLORS = [
    '#3498db', '#e74c3c', '#27ae60', '#9b59b6',
    '#f39c12', '#1abc9c', '#e67e22', '#34495e'
];

const MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const DAY_NAMES = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];

function calendarGetNoteId(widget) {
    const note = widget.closest('.note');
    return note ? note.dataset.note : null;
}

function calendarGetData(noteId) {
    const customizations = loadNoteCustomizations();
    const custom = customizations[noteId] || {};
    const data = custom.calendarData || { calendars: [], events: [] };
    return data;
}

function calendarSaveData(noteId, data) {
    const customizations = loadNoteCustomizations();
    if (!customizations[noteId]) customizations[noteId] = {};
    customizations[noteId].calendarData = data;
    saveNoteCustomizations(customizations);
}

function calendarInit() {
    document.querySelectorAll('.calendar-widget').forEach(widget => {
        const noteId = calendarGetNoteId(widget);
        if (!noteId) return;

        const data = calendarGetData(noteId);
        const year = parseInt(widget.querySelector('.calendar-year-display')?.textContent) || new Date().getFullYear();
        calendarRender(widget, noteId, year);
    });
}

function calendarRender(widget, noteId, year) {
    const data = calendarGetData(noteId);
    const grid = widget.querySelector('.calendar-year-grid');
    const legend = widget.querySelector('.calendar-legend');
    const yearDisplay = widget.querySelector('.calendar-year-display');

    if (yearDisplay) yearDisplay.textContent = year;

    // Render 12 months
    let html = '';
    for (let month = 0; month < 12; month++) {
        html += calendarRenderMonth(year, month, data);
    }
    grid.innerHTML = html;

    // Render legend with event counts
    const counts = calendarCountByType(data, year);
    let legendHtml = '';
    data.calendars.forEach(cal => {
        const count = counts[cal.id] || 0;
        legendHtml += `<div class="calendar-legend-item">
            <span class="calendar-legend-dot" style="background:${cal.color}"></span>
            <span>${cal.name}</span>
            <span class="calendar-legend-count">${count}</span>
        </div>`;
    });
    legend.innerHTML = legendHtml;
}

function calendarRenderMonth(year, month, data) {
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startDow = firstDay.getDay();
    const daysInMonth = lastDay.getDate();

    const today = new Date();
    const isCurrentMonth = today.getFullYear() === year && today.getMonth() === month;
    const todayDate = today.getDate();

    let html = `<div class="calendar-month">
        <div class="calendar-month-name">${MONTH_NAMES[month]}</div>
        <div class="calendar-month-grid">`;

    // Day of week headers
    DAY_NAMES.forEach(d => {
        html += `<div class="calendar-dow">${d}</div>`;
    });

    // Empty cells before first day
    for (let i = 0; i < startDow; i++) {
        html += `<div class="calendar-day other-month"></div>`;
    }

    // Days of month
    for (let day = 1; day <= daysInMonth; day++) {
        const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        const dayEvents = calendarGetEventsForDate(data, dateStr);
        const isToday = isCurrentMonth && day === todayDate;

        let classes = 'calendar-day';
        if (isToday) classes += ' today';
        if (dayEvents.length > 0) classes += ' has-events';

        html += `<div class="${classes}" data-date="${dateStr}" onclick="calendarShowDayEvents(this, '${dateStr}')">
            ${day}`;

        if (dayEvents.length > 0) {
            html += `<div class="calendar-event-dots">`;
            // Show up to 3 dots
            const uniqueCals = [...new Set(dayEvents.map(e => e.calendarId))];
            uniqueCals.slice(0, 3).forEach(calId => {
                const cal = data.calendars.find(c => c.id === calId);
                if (cal) {
                    html += `<span class="calendar-event-dot" style="background:${cal.color}"></span>`;
                }
            });
            html += `</div>`;
        }

        html += `</div>`;
    }

    html += `</div></div>`;
    return html;
}

function calendarGetEventsForDate(data, dateStr) {
    return data.events.filter(event => {
        // Check if date falls within event range or matches single day
        const startDate = event.startDate.split('T')[0];
        const endDate = event.endDate ? event.endDate.split('T')[0] : startDate;
        return dateStr >= startDate && dateStr <= endDate;
    });
}

function calendarCountByType(data, year) {
    const counts = {};
    data.calendars.forEach(cal => counts[cal.id] = 0);

    const yearStart = new Date(year, 0, 1);
    const yearEnd = new Date(year, 11, 31);

    data.events.forEach(event => {
        if (!counts.hasOwnProperty(event.calendarId)) return;

        const startDate = new Date(event.startDate.split('T')[0]);
        const endDate = new Date((event.endDate || event.startDate).split('T')[0]);

        // Clamp to year boundaries
        const countStart = startDate < yearStart ? yearStart : startDate;
        const countEnd = endDate > yearEnd ? yearEnd : endDate;

        if (countStart <= countEnd) {
            // Count number of days
            const days = Math.round((countEnd - countStart) / (1000 * 60 * 60 * 24)) + 1;
            counts[event.calendarId] += days;
        }
    });

    return counts;
}

function calendarCountTotal(data) {
    const counts = {};
    data.calendars.forEach(cal => counts[cal.id] = 0);

    data.events.forEach(event => {
        if (!counts.hasOwnProperty(event.calendarId)) return;

        const startDate = new Date(event.startDate.split('T')[0]);
        const endDate = new Date((event.endDate || event.startDate).split('T')[0]);

        // Count number of days
        const days = Math.round((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
        counts[event.calendarId] += days;
    });

    return counts;
}

function calendarPrevYear(btn) {
    const widget = btn.closest('.calendar-widget');
    const noteId = calendarGetNoteId(widget);
    const yearDisplay = widget.querySelector('.calendar-year-display');
    const year = parseInt(yearDisplay.textContent) - 1;
    calendarRender(widget, noteId, year);
}

function calendarNextYear(btn) {
    const widget = btn.closest('.calendar-widget');
    const noteId = calendarGetNoteId(widget);
    const yearDisplay = widget.querySelector('.calendar-year-display');
    const year = parseInt(yearDisplay.textContent) + 1;
    calendarRender(widget, noteId, year);
}

function calendarShowDayEvents(dayEl, dateStr) {
    // Remove existing tooltip
    document.querySelectorAll('.calendar-day-tooltip').forEach(t => t.remove());

    const widget = dayEl.closest('.calendar-widget');
    const noteId = calendarGetNoteId(widget);
    const data = calendarGetData(noteId);
    const events = calendarGetEventsForDate(data, dateStr);

    const date = new Date(dateStr + 'T00:00:00');
    const dateFormatted = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });

    let html = `<div class="calendar-day-tooltip" data-note-id="${noteId}" data-date="${dateStr}">
        <div class="calendar-day-tooltip-date">${dateFormatted}</div>`;

    events.forEach(event => {
        const cal = data.calendars.find(c => c.id === event.calendarId);
        const color = cal ? cal.color : '#999';
        html += `<div class="calendar-day-tooltip-event">
            <span class="calendar-day-tooltip-dot" style="background:${color}"></span>
            <span class="calendar-day-tooltip-text">${event.summary}</span>
            <button class="calendar-event-delete" onclick="calendarDeleteEvent('${event.uid}')" title="Delete event">&times;</button>
        </div>`;
    });

    // Add event form
    if (data.calendars.length > 0) {
        const calendarOptions = data.calendars.map(cal =>
            `<option value="${cal.id}">${cal.name}</option>`
        ).join('');
        html += `<div class="calendar-day-add-form">
            <input type="text" class="calendar-day-add-input" placeholder="New event..." id="calendarDayEventTitle">
            <select class="calendar-day-add-select" id="calendarDayEventCalendar">${calendarOptions}</select>
            <button class="calendar-day-add-btn" onclick="calendarAddEventFromDay(this)">+</button>
        </div>`;
    } else {
        html += `<div style="font-size:10px;color:var(--text-muted);margin-top:6px;">Add a calendar first to create events</div>`;
    }

    html += `</div>`;

    const tooltip = document.createElement('div');
    tooltip.innerHTML = html;
    const tooltipEl = tooltip.firstChild;
    document.body.appendChild(tooltipEl);

    // Position tooltip
    const rect = dayEl.getBoundingClientRect();
    let left = rect.left + window.scrollX;
    let top = rect.bottom + window.scrollY + 5;

    // Adjust if tooltip would go off-screen
    tooltipEl.style.left = left + 'px';
    tooltipEl.style.top = top + 'px';

    // Focus the input and add Enter key support
    setTimeout(() => {
        const input = tooltipEl.querySelector('.calendar-day-add-input');
        if (input) {
            input.focus();
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const btn = tooltipEl.querySelector('.calendar-day-add-btn');
                    if (btn) btn.click();
                }
            });
        }
    }, 0);

    // Close on click outside
    const closeHandler = (e) => {
        if (!tooltipEl.contains(e.target) && e.target !== dayEl) {
            tooltipEl.remove();
            document.removeEventListener('click', closeHandler);
        }
    };
    setTimeout(() => document.addEventListener('click', closeHandler), 0);
}

function calendarOpenManage(btn) {
    const widget = btn.closest('.calendar-widget');
    const noteId = calendarGetNoteId(widget);
    const data = calendarGetData(noteId);

    // Create modal if it doesn't exist
    let modal = document.getElementById('calendarManageModal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'calendarManageModal';
        modal.className = 'calendar-manage-modal';
        modal.innerHTML = `
            <div class="calendar-manage-content">
                <span class="calendar-manage-close" onclick="calendarCloseManage()">&times;</span>
                <h3>Manage Calendars</h3>
                <div class="calendar-list" id="calendarManageList"></div>
                <div class="calendar-add-form">
                    <h4>Add New Calendar</h4>
                    <div class="calendar-add-row">
                        <input type="text" class="calendar-add-name" id="calendarAddName" placeholder="Calendar name...">
                    </div>
                    <div class="calendar-color-picker" id="calendarColorPicker"></div>
                    <button class="calendar-add-btn" onclick="calendarAddCalendar()">Add Calendar</button>
                </div>
                <div class="calendar-import-section">
                    <h4>Add Event</h4>
                    <div class="calendar-import-row" style="margin-bottom:8px;">
                        <label style="font-size:11px;color:var(--text-muted);min-width:60px;">Title:</label>
                        <input type="text" class="calendar-add-name" id="calendarEventTitle" placeholder="Event title..." style="flex:1;">
                    </div>
                    <div class="calendar-import-row" style="margin-bottom:8px;">
                        <label style="font-size:11px;color:var(--text-muted);min-width:60px;">Start:</label>
                        <input type="date" class="calendar-add-name" id="calendarEventStart" style="flex:1;">
                    </div>
                    <div class="calendar-import-row" style="margin-bottom:8px;">
                        <label style="font-size:11px;color:var(--text-muted);min-width:60px;">End:</label>
                        <input type="date" class="calendar-add-name" id="calendarEventEnd" style="flex:1;">
                    </div>
                    <div class="calendar-import-row" style="margin-bottom:8px;">
                        <label style="font-size:11px;color:var(--text-muted);min-width:60px;">Calendar:</label>
                        <select class="calendar-import-select" id="calendarEventCalendar" style="flex:1;"></select>
                    </div>
                    <button class="calendar-add-btn" onclick="calendarAddEvent()">Add Event</button>
                </div>
                <div class="calendar-import-section">
                    <h4>Import .ics</h4>
                    <div class="calendar-import-row" style="margin-bottom:8px;">
                        <label style="font-size:11px;color:var(--text-muted);min-width:60px;">From file:</label>
                        <input type="file" class="calendar-import-file" id="calendarImportFile" accept=".ics">
                    </div>
                    <div class="calendar-import-row" style="margin-bottom:8px;">
                        <label style="font-size:11px;color:var(--text-muted);min-width:60px;">From URL:</label>
                        <input type="text" class="calendar-add-name" id="calendarImportUrl" placeholder="https://example.com/calendar.ics" style="flex:1;">
                        <button class="calendar-add-btn" onclick="calendarImportFromUrl()" style="padding:6px 10px;">Fetch</button>
                    </div>
                    <div class="calendar-import-row">
                        <label style="font-size:11px;color:var(--text-muted);min-width:60px;">To calendar:</label>
                        <select class="calendar-import-select" id="calendarImportSelect"></select>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);

        // File import handler
        document.getElementById('calendarImportFile').addEventListener('change', calendarHandleFileImport);
    }

    modal.dataset.noteId = noteId;
    modal.classList.add('open');

    // Render color picker
    const colorPicker = document.getElementById('calendarColorPicker');
    colorPicker.innerHTML = CALENDAR_COLORS.map((color, i) =>
        `<div class="calendar-color-option${i === 0 ? ' selected' : ''}"
             style="background:${color}"
             data-color="${color}"
             onclick="calendarSelectColor(this)"></div>`
    ).join('');

    // Render calendar list
    calendarRenderManageList(data);
}

function calendarCloseManage() {
    const modal = document.getElementById('calendarManageModal');
    if (modal) modal.classList.remove('open');
}

function calendarSelectColor(el) {
    document.querySelectorAll('.calendar-color-option').forEach(opt => opt.classList.remove('selected'));
    el.classList.add('selected');
}

function calendarRenderManageList(data) {
    const list = document.getElementById('calendarManageList');
    const importSelect = document.getElementById('calendarImportSelect');
    const eventSelect = document.getElementById('calendarEventCalendar');

    if (data.calendars.length === 0) {
        list.innerHTML = '<p style="color:var(--text-muted);font-size:12px;">No calendars yet. Add one below.</p>';
        const emptyOption = '<option value="">Add a calendar first</option>';
        importSelect.innerHTML = emptyOption;
        eventSelect.innerHTML = emptyOption;
        importSelect.disabled = true;
        eventSelect.disabled = true;
    } else {
        const counts = calendarCountTotal(data);

        list.innerHTML = data.calendars.map(cal => `
            <div class="calendar-list-item">
                <span class="calendar-list-color" style="background:${cal.color}"></span>
                <span class="calendar-list-name">${cal.name}</span>
                <span class="calendar-list-count">${counts[cal.id] || 0} days</span>
                <button class="calendar-list-remove" onclick="calendarRemoveCalendar('${cal.id}')">&times;</button>
            </div>
        `).join('');

        const calendarOptions = data.calendars.map(cal =>
            `<option value="${cal.id}">${cal.name}</option>`
        ).join('');
        importSelect.innerHTML = calendarOptions;
        eventSelect.innerHTML = calendarOptions;
        importSelect.disabled = false;
        eventSelect.disabled = false;
    }
}

function calendarAddCalendar() {
    const modal = document.getElementById('calendarManageModal');
    const noteId = modal.dataset.noteId;
    const nameInput = document.getElementById('calendarAddName');
    const colorEl = document.querySelector('.calendar-color-option.selected');

    const name = nameInput.value.trim();
    if (!name) {
        nameInput.focus();
        return;
    }

    const color = colorEl ? colorEl.dataset.color : CALENDAR_COLORS[0];
    const data = calendarGetData(noteId);

    const newCal = {
        id: 'cal_' + Date.now(),
        name: name,
        color: color
    };

    data.calendars.push(newCal);
    calendarSaveData(noteId, data);

    nameInput.value = '';
    calendarRenderManageList(data);

    // Re-render calendar
    const widget = document.querySelector(`.note[data-note="${noteId}"] .calendar-widget`);
    if (widget) {
        const year = parseInt(widget.querySelector('.calendar-year-display')?.textContent) || new Date().getFullYear();
        calendarRender(widget, noteId, year);
    }
}

function calendarAddEvent() {
    const modal = document.getElementById('calendarManageModal');
    const noteId = modal.dataset.noteId;

    const titleInput = document.getElementById('calendarEventTitle');
    const startInput = document.getElementById('calendarEventStart');
    const endInput = document.getElementById('calendarEventEnd');
    const calendarSelect = document.getElementById('calendarEventCalendar');

    const title = titleInput.value.trim();
    const startDate = startInput.value;
    const endDate = endInput.value || startDate;
    const calendarId = calendarSelect.value;

    if (!title) {
        titleInput.focus();
        return;
    }

    if (!startDate) {
        startInput.focus();
        return;
    }

    if (!calendarId) {
        alert('Please create a calendar first.');
        return;
    }

    const data = calendarGetData(noteId);

    const newEvent = {
        uid: 'evt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        calendarId: calendarId,
        summary: title,
        startDate: startDate,
        endDate: endDate
    };

    data.events.push(newEvent);
    calendarSaveData(noteId, data);

    // Clear inputs
    titleInput.value = '';
    startInput.value = '';
    endInput.value = '';

    calendarRenderManageList(data);

    // Re-render calendar
    const widget = document.querySelector(`.note[data-note="${noteId}"] .calendar-widget`);
    if (widget) {
        const year = parseInt(widget.querySelector('.calendar-year-display')?.textContent) || new Date().getFullYear();
        calendarRender(widget, noteId, year);
    }
}

function calendarAddEventFromDay(btn) {
    const tooltip = btn.closest('.calendar-day-tooltip');
    const noteId = tooltip.dataset.noteId;
    const dateStr = tooltip.dataset.date;

    const titleInput = tooltip.querySelector('.calendar-day-add-input');
    const calendarSelect = tooltip.querySelector('.calendar-day-add-select');

    const title = titleInput.value.trim();
    const calendarId = calendarSelect.value;

    if (!title) {
        titleInput.focus();
        return;
    }

    const data = calendarGetData(noteId);

    const newEvent = {
        uid: 'evt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        calendarId: calendarId,
        summary: title,
        startDate: dateStr,
        endDate: dateStr
    };

    data.events.push(newEvent);
    calendarSaveData(noteId, data);

    // Close tooltip
    tooltip.remove();

    // Re-render calendar
    const widget = document.querySelector(`.note[data-note="${noteId}"] .calendar-widget`);
    if (widget) {
        const year = parseInt(widget.querySelector('.calendar-year-display')?.textContent) || new Date().getFullYear();
        calendarRender(widget, noteId, year);
    }
}

function calendarDeleteEvent(eventUid) {
    const tooltip = document.querySelector('.calendar-day-tooltip');
    if (!tooltip) return;

    const noteId = tooltip.dataset.noteId;
    const dateStr = tooltip.dataset.date;
    const data = calendarGetData(noteId);

    data.events = data.events.filter(e => e.uid !== eventUid);
    calendarSaveData(noteId, data);

    // Close tooltip
    tooltip.remove();

    // Re-render calendar
    const widget = document.querySelector(`.note[data-note="${noteId}"] .calendar-widget`);
    if (widget) {
        const year = parseInt(widget.querySelector('.calendar-year-display')?.textContent) || new Date().getFullYear();
        calendarRender(widget, noteId, year);
    }
}

function calendarRemoveCalendar(calId) {
    const modal = document.getElementById('calendarManageModal');
    const noteId = modal.dataset.noteId;
    const data = calendarGetData(noteId);

    data.calendars = data.calendars.filter(c => c.id !== calId);
    data.events = data.events.filter(e => e.calendarId !== calId);
    calendarSaveData(noteId, data);

    calendarRenderManageList(data);

    // Re-render calendar
    const widget = document.querySelector(`.note[data-note="${noteId}"] .calendar-widget`);
    if (widget) {
        const year = parseInt(widget.querySelector('.calendar-year-display')?.textContent) || new Date().getFullYear();
        calendarRender(widget, noteId, year);
    }
}

function calendarHandleFileImport(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(evt) {
        const content = evt.target.result;
        calendarImportICS(content);
    };
    reader.readAsText(file);

    // Clear the input
    e.target.value = '';
}

async function calendarImportFromUrl() {
    const urlInput = document.getElementById('calendarImportUrl');
    const url = urlInput.value.trim();

    if (!url) {
        urlInput.focus();
        return;
    }

    // Validate URL
    try {
        new URL(url);
    } catch {
        alert('Please enter a valid URL.');
        return;
    }

    const select = document.getElementById('calendarImportSelect');
    if (!select.value) {
        alert('Please create a calendar first before importing events.');
        return;
    }

    // Show loading state
    const fetchBtn = document.querySelector('.calendar-import-section .calendar-add-btn');
    const originalText = fetchBtn.textContent;
    fetchBtn.textContent = 'Fetching...';
    fetchBtn.disabled = true;

    try {
        const response = await fetch(url);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const content = await response.text();

        if (!content.includes('BEGIN:VCALENDAR')) {
            throw new Error('The URL does not appear to contain valid ICS data.');
        }

        calendarImportICS(content);
        urlInput.value = '';
    } catch (error) {
        if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
            alert('Could not fetch the URL. This may be due to CORS restrictions. Try downloading the .ics file and importing it manually.');
        } else {
            alert('Error fetching calendar: ' + error.message);
        }
    } finally {
        fetchBtn.textContent = originalText;
        fetchBtn.disabled = false;
    }
}

function calendarImportICS(content) {
    const modal = document.getElementById('calendarManageModal');
    const noteId = modal.dataset.noteId;
    const select = document.getElementById('calendarImportSelect');
    const calendarId = select.value;

    if (!calendarId) {
        alert('Please create a calendar first before importing events.');
        return;
    }

    const events = parseICSContent(content, calendarId);

    if (events.length === 0) {
        alert('No events found in the ICS file.');
        return;
    }

    const data = calendarGetData(noteId);

    // Add events (avoiding duplicates by UID)
    const existingUids = new Set(data.events.map(e => e.uid));
    let added = 0;

    events.forEach(event => {
        if (!existingUids.has(event.uid)) {
            data.events.push(event);
            existingUids.add(event.uid);
            added++;
        }
    });

    calendarSaveData(noteId, data);
    calendarRenderManageList(data);

    // Re-render calendar
    const widget = document.querySelector(`.note[data-note="${noteId}"] .calendar-widget`);
    if (widget) {
        const year = parseInt(widget.querySelector('.calendar-year-display')?.textContent) || new Date().getFullYear();
        calendarRender(widget, noteId, year);
    }

    alert(`Imported ${added} event(s).`);
}

function parseICSContent(text, calendarId) {
    const events = [];
    const lines = text.replace(/\r\n /g, '').replace(/\r/g, '\n').split('\n');

    let inEvent = false;
    let currentEvent = {};

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        if (line === 'BEGIN:VEVENT') {
            inEvent = true;
            currentEvent = { calendarId };
        } else if (line === 'END:VEVENT') {
            if (currentEvent.startDate && currentEvent.summary) {
                if (!currentEvent.uid) {
                    currentEvent.uid = 'evt_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                }
                if (!currentEvent.endDate) {
                    currentEvent.endDate = currentEvent.startDate;
                }
                events.push(currentEvent);
            }
            inEvent = false;
            currentEvent = {};
        } else if (inEvent) {
            const colonIndex = line.indexOf(':');
            if (colonIndex === -1) continue;

            let key = line.substring(0, colonIndex);
            const value = line.substring(colonIndex + 1);

            // Handle parameters in key (e.g., DTSTART;VALUE=DATE:20240101)
            const semiIndex = key.indexOf(';');
            if (semiIndex !== -1) {
                key = key.substring(0, semiIndex);
            }

            switch (key) {
                case 'UID':
                    currentEvent.uid = value;
                    break;
                case 'SUMMARY':
                    currentEvent.summary = value.replace(/\\,/g, ',').replace(/\\;/g, ';').replace(/\\n/g, '\n');
                    break;
                case 'DTSTART':
                    currentEvent.startDate = parseICSDate(value);
                    break;
                case 'DTEND':
                    // ICS end dates are exclusive for all-day events
                    // If date-only (length 8), subtract one day
                    const cleanedEnd = value.replace('Z', '');
                    if (cleanedEnd.length === 8) {
                        const d = new Date(
                            parseInt(cleanedEnd.substring(0, 4)),
                            parseInt(cleanedEnd.substring(4, 6)) - 1,
                            parseInt(cleanedEnd.substring(6, 8))
                        );
                        d.setDate(d.getDate() - 1);
                        currentEvent.endDate = d.toISOString().split('T')[0];
                    } else {
                        currentEvent.endDate = parseICSDate(value);
                    }
                    break;
                case 'RRULE':
                    // Basic recurring event support - expand first year of occurrences
                    currentEvent.rrule = value;
                    break;
            }
        }
    }

    // Expand recurring events for current year
    const expandedEvents = [];
    events.forEach(event => {
        if (event.rrule) {
            const expanded = expandRRULE(event);
            expandedEvents.push(...expanded);
        } else {
            expandedEvents.push(event);
        }
    });

    return expandedEvents;
}

function parseICSDate(value) {
    // Handle formats: 20240115, 20240115T103000, 20240115T103000Z
    const cleaned = value.replace('Z', '');

    if (cleaned.length === 8) {
        // Date only: YYYYMMDD
        return `${cleaned.substring(0, 4)}-${cleaned.substring(4, 6)}-${cleaned.substring(6, 8)}`;
    } else if (cleaned.length >= 15) {
        // DateTime: YYYYMMDDTHHMMSS
        return `${cleaned.substring(0, 4)}-${cleaned.substring(4, 6)}-${cleaned.substring(6, 8)}T${cleaned.substring(9, 11)}:${cleaned.substring(11, 13)}:${cleaned.substring(13, 15)}`;
    }

    return value;
}

function expandRRULE(event) {
    const events = [event];
    const rrule = event.rrule;

    // Parse RRULE components
    const parts = {};
    rrule.split(';').forEach(part => {
        const [key, val] = part.split('=');
        parts[key] = val;
    });

    if (!parts.FREQ) return events;

    const startDate = new Date(event.startDate);
    const endDate = event.endDate ? new Date(event.endDate) : new Date(event.startDate);
    const duration = endDate - startDate;

    const count = parts.COUNT ? parseInt(parts.COUNT) : 52; // Default to 1 year of weekly events
    const interval = parts.INTERVAL ? parseInt(parts.INTERVAL) : 1;

    let until = parts.UNTIL ? new Date(parseICSDate(parts.UNTIL)) : null;
    if (!until) {
        until = new Date(startDate);
        until.setFullYear(until.getFullYear() + 1);
    }

    let currentDate = new Date(startDate);
    let occurrences = 1;

    while (occurrences < count && currentDate < until) {
        // Advance to next occurrence
        switch (parts.FREQ) {
            case 'DAILY':
                currentDate.setDate(currentDate.getDate() + interval);
                break;
            case 'WEEKLY':
                currentDate.setDate(currentDate.getDate() + (7 * interval));
                break;
            case 'MONTHLY':
                currentDate.setMonth(currentDate.getMonth() + interval);
                break;
            case 'YEARLY':
                currentDate.setFullYear(currentDate.getFullYear() + interval);
                break;
            default:
                return events;
        }

        if (currentDate > until) break;

        const newEndDate = new Date(currentDate.getTime() + duration);
        events.push({
            ...event,
            uid: event.uid + '_' + occurrences,
            startDate: currentDate.toISOString().split('T')[0],
            endDate: newEndDate.toISOString().split('T')[0],
            rrule: undefined
        });

        occurrences++;
    }

    return events;
}

// ==================== Diff Viewer Functions ====================

function diffGetNoteId(element) {
    const note = element.closest('.note');
    return note ? note.dataset.note : null;
}

function diffGetData(noteId) {
    const customizations = loadNoteCustomizations();
    const custom = customizations[noteId] || {};
    return custom.diffData || {
        original: '',
        modified: '',
        mode: 'edit',
        viewType: 'split',
        hideWhitespace: false
    };
}

function diffSaveData(noteId, data) {
    const customizations = loadNoteCustomizations();
    if (!customizations[noteId]) customizations[noteId] = {};
    customizations[noteId].diffData = data;
    saveNoteCustomizations(customizations);
}

function diffInit() {
    document.querySelectorAll('.diff-widget').forEach(widget => {
        const noteId = diffGetNoteId(widget);
        if (!noteId) return;

        const data = diffGetData(noteId);

        // Populate textareas
        const textareas = widget.querySelectorAll('.diff-edit-pane textarea');
        if (textareas[0]) textareas[0].value = data.original;
        if (textareas[1]) textareas[1].value = data.modified;

        // Set mode
        const modeButtons = widget.querySelectorAll('.diff-mode-btn');
        modeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.textContent.toLowerCase() === data.mode);
        });

        // Set view type
        const viewButtons = widget.querySelectorAll('.diff-view-btn');
        viewButtons.forEach(btn => {
            const btnView = btn.textContent.toLowerCase();
            btn.classList.toggle('active', btnView === data.viewType);
        });

        // Set hide whitespace checkbox
        const wsCheckbox = widget.querySelector('.diff-whitespace-toggle input');
        if (wsCheckbox) wsCheckbox.checked = data.hideWhitespace;

        // Show correct container
        const editContainer = widget.querySelector('.diff-edit-container');
        const viewContainer = widget.querySelector('.diff-view-container');
        if (data.mode === 'view') {
            editContainer.classList.add('hidden');
            viewContainer.classList.add('active');
            diffRenderOutput(widget, noteId);
        } else {
            editContainer.classList.remove('hidden');
            viewContainer.classList.remove('active');
        }

        // Update stats
        diffUpdateStats(widget, noteId);
    });
}

function diffOnInput(textarea, field) {
    const noteId = diffGetNoteId(textarea);
    if (!noteId) return;

    const data = diffGetData(noteId);
    data[field] = textarea.value;
    diffSaveData(noteId, data);

    const widget = textarea.closest('.diff-widget');
    diffUpdateStats(widget, noteId);
}

function diffSetMode(btn, mode) {
    const widget = btn.closest('.diff-widget');
    const noteId = diffGetNoteId(widget);
    if (!noteId) return;

    const data = diffGetData(noteId);
    data.mode = mode;
    diffSaveData(noteId, data);

    // Update button states
    widget.querySelectorAll('.diff-mode-btn').forEach(b => {
        b.classList.toggle('active', b.textContent.toLowerCase() === mode);
    });

    // Toggle containers
    const editContainer = widget.querySelector('.diff-edit-container');
    const viewContainer = widget.querySelector('.diff-view-container');

    if (mode === 'view') {
        editContainer.classList.add('hidden');
        viewContainer.classList.add('active');
        diffRenderOutput(widget, noteId);
    } else {
        editContainer.classList.remove('hidden');
        viewContainer.classList.remove('active');
    }
}

function diffSetView(btn, viewType) {
    const widget = btn.closest('.diff-widget');
    const noteId = diffGetNoteId(widget);
    if (!noteId) return;

    const data = diffGetData(noteId);
    data.viewType = viewType;
    diffSaveData(noteId, data);

    // Update button states
    widget.querySelectorAll('.diff-view-btn').forEach(b => {
        const bView = b.textContent.toLowerCase();
        b.classList.toggle('active', bView === viewType);
    });

    // Re-render if in view mode
    if (data.mode === 'view') {
        diffRenderOutput(widget, noteId);
    }
}

function diffToggleWhitespace(checkbox) {
    const widget = checkbox.closest('.diff-widget');
    const noteId = diffGetNoteId(widget);
    if (!noteId) return;

    const data = diffGetData(noteId);
    data.hideWhitespace = checkbox.checked;
    diffSaveData(noteId, data);

    // Re-render if in view mode
    if (data.mode === 'view') {
        diffRenderOutput(widget, noteId);
    }

    diffUpdateStats(widget, noteId);
}

function diffSyncScroll(textarea, source) {
    const widget = textarea.closest('.diff-widget');
    const textareas = widget.querySelectorAll('.diff-edit-pane textarea');

    const other = source === 'original' ? textareas[1] : textareas[0];
    if (other && other !== textarea) {
        other.scrollTop = textarea.scrollTop;
        other.scrollLeft = textarea.scrollLeft;
    }
}

// LCS-based diff algorithm
function computeDiff(original, modified, hideWhitespace) {
    let origLines = original.split('\n');
    let modLines = modified.split('\n');

    if (hideWhitespace) {
        // For comparison, normalize whitespace but keep original for display
        const normalize = line => line.replace(/\s+/g, ' ').trim();
        const origNorm = origLines.map(normalize);
        const modNorm = modLines.map(normalize);

        const lcs = buildLCSMatrix(origNorm, modNorm);
        return backtrackDiff(lcs, origNorm, modNorm, origLines, modLines);
    }

    const lcs = buildLCSMatrix(origLines, modLines);
    return backtrackDiff(lcs, origLines, modLines, origLines, modLines);
}

function buildLCSMatrix(a, b) {
    const m = a.length;
    const n = b.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (a[i - 1] === b[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp;
}

function backtrackDiff(dp, aNorm, bNorm, aOrig, bOrig) {
    const result = [];
    let i = aNorm.length;
    let j = bNorm.length;

    const stack = [];

    while (i > 0 || j > 0) {
        if (i > 0 && j > 0 && aNorm[i - 1] === bNorm[j - 1]) {
            stack.push({ type: 'unchanged', origLine: i, modLine: j, origContent: aOrig[i - 1], modContent: bOrig[j - 1] });
            i--;
            j--;
        } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
            stack.push({ type: 'addition', modLine: j, content: bOrig[j - 1] });
            j--;
        } else {
            stack.push({ type: 'deletion', origLine: i, content: aOrig[i - 1] });
            i--;
        }
    }

    // Reverse to get correct order
    while (stack.length) {
        result.push(stack.pop());
    }

    return result;
}

function diffRenderOutput(widget, noteId) {
    const data = diffGetData(noteId);
    const output = widget.querySelector('.diff-output');

    if (!data.original && !data.modified) {
        output.innerHTML = '<div class="diff-empty-message">Enter text in both panes to see the diff</div>';
        return;
    }

    const diff = computeDiff(data.original, data.modified, data.hideWhitespace);

    if (data.viewType === 'split') {
        output.innerHTML = renderSplitView(diff);
    } else {
        output.innerHTML = renderUnifiedView(diff);
    }
}

function renderSplitView(diff) {
    let leftLines = '';
    let rightLines = '';

    diff.forEach(item => {
        if (item.type === 'unchanged') {
            leftLines += renderDiffLine(item.origLine, item.origContent, 'unchanged');
            rightLines += renderDiffLine(item.modLine, item.modContent, 'unchanged');
        } else if (item.type === 'deletion') {
            leftLines += renderDiffLine(item.origLine, item.content, 'deletion');
            rightLines += renderDiffLine('', '', 'empty');
        } else if (item.type === 'addition') {
            leftLines += renderDiffLine('', '', 'empty');
            rightLines += renderDiffLine(item.modLine, item.content, 'addition');
        }
    });

    return `
        <div class="diff-split-view">
            <div class="diff-split-pane">
                <div class="diff-split-header">Original</div>
                ${leftLines}
            </div>
            <div class="diff-split-pane">
                <div class="diff-split-header">Modified</div>
                ${rightLines}
            </div>
        </div>
    `;
}

function renderUnifiedView(diff) {
    let lines = '';

    diff.forEach(item => {
        if (item.type === 'unchanged') {
            lines += renderUnifiedLine(item.origLine, item.modLine, item.origContent, 'unchanged', ' ');
        } else if (item.type === 'deletion') {
            lines += renderUnifiedLine(item.origLine, '', item.content, 'deletion', '-');
        } else if (item.type === 'addition') {
            lines += renderUnifiedLine('', item.modLine, item.content, 'addition', '+');
        }
    });

    return `<div class="diff-unified-view">${lines}</div>`;
}

function renderDiffLine(lineNum, content, type) {
    const escapedContent = escapeHtml(content || '');
    const displayContent = escapedContent || '&nbsp;';
    return `
        <div class="diff-line ${type}">
            <div class="diff-gutter">${lineNum || ''}</div>
            <div class="diff-content">${displayContent}</div>
        </div>
    `;
}

function renderUnifiedLine(origLine, modLine, content, type, prefix) {
    const escapedContent = escapeHtml(content || '');
    const lineInfo = origLine && modLine ? `${origLine}/${modLine}` : (origLine || modLine || '');
    return `
        <div class="diff-line ${type}">
            <div class="diff-gutter">${lineInfo}</div>
            <div class="diff-prefix">${prefix}</div>
            <div class="diff-content">${escapedContent || '&nbsp;'}</div>
        </div>
    `;
}

function diffUpdateStats(widget, noteId) {
    const data = diffGetData(noteId);
    const statsEl = widget.querySelector('.diff-stats');

    if (!data.original && !data.modified) {
        statsEl.innerHTML = '';
        return;
    }

    const diff = computeDiff(data.original, data.modified, data.hideWhitespace);

    let additions = 0;
    let deletions = 0;

    diff.forEach(item => {
        if (item.type === 'addition') additions++;
        if (item.type === 'deletion') deletions++;
    });

    statsEl.innerHTML = `
        <span class="diff-stats-additions">+${additions} addition${additions !== 1 ? 's' : ''}</span>
        <span class="diff-stats-deletions">-${deletions} deletion${deletions !== 1 ? 's' : ''}</span>
    `;
}

// ==================== Sequence Diagram Functions ====================

function seqGetNoteId(element) {
    const note = element.closest('.note');
    return note ? note.dataset.note : null;
}

function seqGetData(noteId) {
    const customizations = loadNoteCustomizations();
    const custom = customizations[noteId] || {};
    return custom.seqData || {
        text: '',
        mode: 'split'
    };
}

function seqSaveData(noteId, data) {
    const customizations = loadNoteCustomizations();
    if (!customizations[noteId]) customizations[noteId] = {};
    customizations[noteId].seqData = data;
    saveNoteCustomizations(customizations);
}

function seqInit() {
    document.querySelectorAll('.seq-widget').forEach(widget => {
        const noteId = seqGetNoteId(widget);
        if (!noteId) return;

        const data = seqGetData(noteId);

        // Populate all textareas
        widget.querySelectorAll('textarea').forEach(ta => {
            ta.value = data.text;
        });

        // Set mode buttons
        const modeButtons = widget.querySelectorAll('.seq-mode-btn');
        modeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.textContent.toLowerCase() === data.mode);
        });

        // Show correct container
        seqUpdateContainers(widget, data.mode, noteId);
    });
}

function seqUpdateContainers(widget, mode, noteId) {
    const editContainer = widget.querySelector('.seq-edit-container');
    const splitContainer = widget.querySelector('.seq-split-container');
    const viewContainer = widget.querySelector('.seq-view-container');

    // Hide all first
    editContainer.classList.remove('active');
    splitContainer.classList.remove('active');
    viewContainer.classList.remove('active');

    if (mode === 'edit') {
        editContainer.classList.add('active');
    } else if (mode === 'split') {
        splitContainer.classList.add('active');
        seqRenderDiagram(widget, noteId, '.seq-split-container .seq-diagram');
    } else if (mode === 'view') {
        viewContainer.classList.add('active');
        seqRenderDiagram(widget, noteId, '.seq-view-container .seq-diagram');
    }
}

function seqOnInput(textarea) {
    const widget = textarea.closest('.seq-widget');
    const noteId = seqGetNoteId(textarea);
    if (!noteId) return;

    const data = seqGetData(noteId);
    data.text = textarea.value;
    seqSaveData(noteId, data);

    // Sync all textareas in the widget
    widget.querySelectorAll('textarea').forEach(ta => {
        if (ta !== textarea) ta.value = textarea.value;
    });

    // Live render if in split mode
    if (data.mode === 'split') {
        seqRenderDiagram(widget, noteId, '.seq-split-container .seq-diagram');
    }
}

function seqSetMode(btn, mode) {
    const widget = btn.closest('.seq-widget');
    const noteId = seqGetNoteId(widget);
    if (!noteId) return;

    const data = seqGetData(noteId);
    data.mode = mode;
    seqSaveData(noteId, data);

    // Update button states
    widget.querySelectorAll('.seq-mode-btn').forEach(b => {
        b.classList.toggle('active', b.textContent.toLowerCase() === mode);
    });

    // Sync textarea content before switching
    const currentText = data.text;
    widget.querySelectorAll('textarea').forEach(ta => {
        ta.value = currentText;
    });

    // Update containers
    seqUpdateContainers(widget, mode, noteId);
}

function seqShowHelp(btn) {
    // Create modal if it doesn't exist
    let modal = document.querySelector('.seq-help-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.className = 'seq-help-modal';
        modal.innerHTML = `
            <div class="seq-help-content">
                <span class="seq-help-close" onclick="this.closest('.seq-help-modal').classList.remove('open')">&times;</span>
                <h3>Sequence Diagram Syntax</h3>
                <p><strong>Messages:</strong></p>
                <pre>Participant1 -> Participant2: Message text</pre>
                <p><code>-></code> Solid arrow (request/call)</p>
                <p><code>--></code> Dashed arrow (response/return)</p>
                <p><strong>Self-messages:</strong></p>
                <pre>Alice -> Alice: Think about it</pre>
                <p><strong>Notes:</strong></p>
                <pre>Note left of Actor: Text
Note right of Actor: Text
Note over Actor: Text
Note over Actor1, Actor2: Text</pre>
                <p><strong>Colors:</strong></p>
                <p>Add <code>[color]</code> at end of line:</p>
                <pre>A -> B: Request [red]
A -> B: Request [line:red, text:blue]
Note over A: Info [#90EE90]
Note over A: Info [bg:pink, text:black]</pre>
                <p>Message options: <code>line</code>, <code>text</code>, <code>number</code></p>
                <p>Note options: <code>bg</code>, <code>text</code>, <code>border</code></p>
                <p><strong>Example:</strong></p>
                <pre>Client -> Server: HTTP Request [green]
Note right of Server: Validate [#ffe0b0]
Server -> Database: Query [blue]
Database --> Server: Results [purple]
Server --> Client: HTTP Response [green]</pre>
                <p>Participants are automatically detected. Each arrow is numbered sequentially.</p>
            </div>
        `;
        document.body.appendChild(modal);

        // Close on backdrop click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.classList.remove('open');
        });
    }
    modal.classList.add('open');
}

function seqParseColors(text) {
    // Parse color options from end of text: [color] or [bg:color, line:color, text:color]
    const colorMatch = text.match(/\s*\[([^\]]+)\]\s*$/);
    if (!colorMatch) {
        return { text: text.trim(), colors: {} };
    }

    const cleanText = text.substring(0, text.lastIndexOf('[')).trim();
    const colorStr = colorMatch[1].trim();
    const colors = {};

    // Check if it's a simple color or key:value pairs
    if (colorStr.includes(':')) {
        // Parse key:value pairs like "bg:yellow, line:red, text:black"
        colorStr.split(',').forEach(part => {
            const [key, value] = part.split(':').map(s => s.trim());
            if (key && value) {
                colors[key] = value;
            }
        });
    } else {
        // Simple color - use as primary (line for messages, bg for notes)
        colors.primary = colorStr;
    }

    return { text: cleanText, colors };
}

function seqParseText(text) {
    const lines = text.split('\n').filter(line => line.trim());
    const participants = [];
    const items = []; // Can be messages or notes
    const participantSet = new Set();
    let messageCount = 0;

    lines.forEach((line, index) => {
        // Match note syntax: Note left/right/over Actor: Text
        // or: Note over Actor1, Actor2: Text
        const noteMatch = line.match(/^\s*note\s+(left\s+of|right\s+of|over)\s+([^:]+?)\s*:\s*(.*)$/i);
        if (noteMatch) {
            const position = noteMatch[1].toLowerCase().replace(/\s+/g, '');
            const actorsStr = noteMatch[2].trim();
            const rawNoteText = noteMatch[3].trim();

            // Parse colors from note text
            const { text: noteText, colors } = seqParseColors(rawNoteText);

            // Parse actors (can be comma-separated for "over")
            const actors = actorsStr.split(',').map(a => a.trim()).filter(a => a);

            // Add actors to participants if not already present
            actors.forEach(actor => {
                if (!participantSet.has(actor)) {
                    participantSet.add(actor);
                    participants.push(actor);
                }
            });

            items.push({
                type: 'note',
                position: position, // 'leftof', 'rightof', or 'over'
                actors: actors,
                text: noteText,
                colors: {
                    bg: colors.bg || colors.primary || null,
                    text: colors.text || null,
                    border: colors.border || colors.line || null
                }
            });
            return;
        }

        // Match: Participant1 -> Participant2: Message
        // or: Participant1 --> Participant2: Message
        const match = line.match(/^\s*([^-]+?)\s*(-->|->)\s*([^:]+?)\s*:\s*(.*)$/);
        if (match) {
            const from = match[1].trim();
            const arrowType = match[2];
            const to = match[3].trim();
            const rawMessage = match[4].trim();

            // Parse colors from message
            const { text: message, colors } = seqParseColors(rawMessage);

            // Add participants in order of appearance
            if (!participantSet.has(from)) {
                participantSet.add(from);
                participants.push(from);
            }
            if (!participantSet.has(to)) {
                participantSet.add(to);
                participants.push(to);
            }

            messageCount++;
            items.push({
                type: 'message',
                from,
                to,
                message,
                dashed: arrowType === '-->',
                number: messageCount,
                colors: {
                    line: colors.line || colors.primary || null,
                    text: colors.text || null,
                    number: colors.number || colors.bg || null
                }
            });
        }
    });

    return { participants, items };
}

function seqRenderDiagram(widget, noteId, containerSelector) {
    const data = seqGetData(noteId);
    const container = widget.querySelector(containerSelector || '.seq-diagram');

    if (!container) return;

    if (!data.text.trim()) {
        container.innerHTML = '<div class="seq-error-message">Enter sequence diagram notation to see the diagram</div>';
        return;
    }

    const { participants, items } = seqParseText(data.text);

    if (participants.length === 0) {
        container.innerHTML = '<div class="seq-error-message">No valid entries found. Use syntax: Actor -> Actor: Message</div>';
        return;
    }

    // Calculate dimensions
    const boxWidth = 100;
    const boxHeight = 36;
    const boxPadding = 40;
    const itemSpacing = 50;
    const topMargin = 20;
    const bottomMargin = 50;
    const numberRadius = 10;
    const noteWidth = 120;
    const noteHeight = 30;
    const notePadding = 8;

    const totalWidth = participants.length * (boxWidth + boxPadding) - boxPadding + 40;
    const totalHeight = topMargin + boxHeight + (items.length * itemSpacing) + boxHeight + bottomMargin;

    // Build SVG
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${totalWidth} ${totalHeight}" width="${totalWidth}" height="${totalHeight}">`;

    // Calculate participant positions
    const participantX = {};
    participants.forEach((p, i) => {
        participantX[p] = 20 + i * (boxWidth + boxPadding) + boxWidth / 2;
    });

    // Draw lifelines (behind everything)
    participants.forEach(p => {
        const x = participantX[p];
        const y1 = topMargin + boxHeight;
        const y2 = totalHeight - bottomMargin - boxHeight;
        svg += `<line class="seq-lifeline" x1="${x}" y1="${y1}" x2="${x}" y2="${y2}" />`;
    });

    // Draw top participant boxes
    participants.forEach(p => {
        const x = participantX[p] - boxWidth / 2;
        const y = topMargin;
        svg += `<rect class="seq-participant-box" x="${x}" y="${y}" width="${boxWidth}" height="${boxHeight}" rx="4" />`;
        svg += `<text class="seq-participant-text" x="${participantX[p]}" y="${y + boxHeight / 2}">${escapeHtml(p)}</text>`;
    });

    // Draw bottom participant boxes
    participants.forEach(p => {
        const x = participantX[p] - boxWidth / 2;
        const y = totalHeight - bottomMargin - boxHeight;
        svg += `<rect class="seq-participant-box" x="${x}" y="${y}" width="${boxWidth}" height="${boxHeight}" rx="4" />`;
        svg += `<text class="seq-participant-text" x="${participantX[p]}" y="${y + boxHeight / 2}">${escapeHtml(p)}</text>`;
    });

    // Draw items (messages and notes)
    items.forEach((item, i) => {
        const y = topMargin + boxHeight + (i + 1) * itemSpacing - itemSpacing / 2;

        if (item.type === 'note') {
            // Render note with optional colors
            const actor = item.actors[0];
            const actorX = participantX[actor] || 0;
            let noteX, textAnchor;

            // Build style strings for colors
            const noteColors = item.colors || {};
            let boxStyle = '';
            let textStyle = '';
            if (noteColors.bg) boxStyle += `fill:${noteColors.bg};`;
            if (noteColors.border) boxStyle += `stroke:${noteColors.border};`;
            if (noteColors.text) textStyle += `fill:${noteColors.text};`;

            if (item.position === 'leftof') {
                noteX = actorX - boxWidth / 2 - noteWidth - 10;
                textAnchor = 'start';
            } else if (item.position === 'rightof') {
                noteX = actorX + boxWidth / 2 + 10;
                textAnchor = 'start';
            } else if (item.position === 'over') {
                if (item.actors.length > 1) {
                    // Note spanning multiple actors
                    const actor2 = item.actors[1];
                    const actor2X = participantX[actor2] || actorX;
                    const minX = Math.min(actorX, actor2X);
                    const maxX = Math.max(actorX, actor2X);
                    noteX = minX - noteWidth / 2;
                    const spanWidth = maxX - minX + noteWidth;
                    svg += `<rect class="seq-note-box" x="${noteX}" y="${y - noteHeight / 2}" width="${spanWidth}" height="${noteHeight}" rx="2"${boxStyle ? ` style="${boxStyle}"` : ''} />`;
                    svg += `<text class="seq-note-text" x="${(minX + maxX) / 2}" y="${y}" text-anchor="middle" dominant-baseline="middle"${textStyle ? ` style="${textStyle}"` : ''}>${escapeHtml(item.text)}</text>`;
                    return;
                } else {
                    noteX = actorX - noteWidth / 2;
                    textAnchor = 'middle';
                }
            }

            svg += `<rect class="seq-note-box" x="${noteX}" y="${y - noteHeight / 2}" width="${noteWidth}" height="${noteHeight}" rx="2"${boxStyle ? ` style="${boxStyle}"` : ''} />`;
            const textX = item.position === 'over' ? actorX : noteX + notePadding;
            svg += `<text class="seq-note-text" x="${textX}" y="${y}" text-anchor="${textAnchor}" dominant-baseline="middle"${textStyle ? ` style="${textStyle}"` : ''}>${escapeHtml(item.text)}</text>`;

        } else if (item.type === 'message') {
            // Render message with optional colors
            const fromX = participantX[item.from];
            const toX = participantX[item.to];
            const dashedClass = item.dashed ? ' dashed' : '';

            // Build style strings for colors
            const msgColors = item.colors || {};
            let lineStyle = '';
            let headStyle = '';
            let labelStyle = '';
            let numBgStyle = '';
            if (msgColors.line) {
                lineStyle = `stroke:${msgColors.line};`;
                headStyle = `fill:${msgColors.line};`;
            }
            if (msgColors.text) labelStyle = `fill:${msgColors.text};`;
            if (msgColors.number) numBgStyle = `fill:${msgColors.number};`;

            if (item.from === item.to) {
                // Self-message: loop to the right
                const loopWidth = 30;
                const loopHeight = 20;
                svg += `<path class="seq-self-arrow${dashedClass}" d="M ${fromX} ${y}
                        L ${fromX + loopWidth} ${y}
                        L ${fromX + loopWidth} ${y + loopHeight}
                        L ${fromX + 8} ${y + loopHeight}"${lineStyle ? ` style="${lineStyle}"` : ''} />`;
                // Arrow head
                svg += `<polygon class="seq-arrow-head" points="${fromX + 8},${y + loopHeight - 4} ${fromX + 8},${y + loopHeight + 4} ${fromX},${y + loopHeight}"${headStyle ? ` style="${headStyle}"` : ''} />`;
                // Label
                svg += `<text class="seq-arrow-label" x="${fromX + loopWidth + 5}" y="${y + loopHeight / 2}"${labelStyle ? ` style="${labelStyle}"` : ''}>${escapeHtml(item.message)}</text>`;
                // Number
                const numBgClass = item.dashed ? 'seq-dashed-number-bg' : 'seq-arrow-number-bg';
                svg += `<circle class="${numBgClass}" cx="${fromX + loopWidth}" cy="${y}" r="${numberRadius}"${numBgStyle ? ` style="${numBgStyle}"` : ''} />`;
                svg += `<text class="seq-arrow-number" x="${fromX + loopWidth}" y="${y}" text-anchor="middle" dominant-baseline="middle">${item.number}</text>`;
            } else {
                // Regular message
                const direction = toX > fromX ? 1 : -1;
                const arrowLength = 8;

                // Arrow line
                svg += `<line class="seq-arrow${dashedClass}" x1="${fromX}" y1="${y}" x2="${toX - direction * arrowLength}" y2="${y}"${lineStyle ? ` style="${lineStyle}"` : ''} />`;

                // Arrow head
                const headX = toX;
                const headY = y;
                svg += `<polygon class="seq-arrow-head" points="${headX},${headY} ${headX - direction * arrowLength},${headY - 4} ${headX - direction * arrowLength},${headY + 4}"${headStyle ? ` style="${headStyle}"` : ''} />`;

                // Label (centered above arrow)
                const labelX = (fromX + toX) / 2;
                svg += `<text class="seq-arrow-label" x="${labelX}" y="${y - 8}" text-anchor="middle"${labelStyle ? ` style="${labelStyle}"` : ''}>${escapeHtml(item.message)}</text>`;

                // Number badge (at the start of arrow)
                const numX = fromX + direction * 15;
                const numBgClass = item.dashed ? 'seq-dashed-number-bg' : 'seq-arrow-number-bg';
                svg += `<circle class="${numBgClass}" cx="${numX}" cy="${y}" r="${numberRadius}"${numBgStyle ? ` style="${numBgStyle}"` : ''} />`;
                svg += `<text class="seq-arrow-number" x="${numX}" y="${y}" text-anchor="middle" dominant-baseline="middle">${item.number}</text>`;
            }
        }
    });

    svg += '</svg>';
    container.innerHTML = svg;
}

// Simple Markdown Parser
function parseMarkdown(text) {
    if (!text) return '';

    // Split into blocks (separated by blank lines)
    const blocks = text.split(/\n\n+/);
    const htmlBlocks = [];

    for (let block of blocks) {
        block = block.trim();
        if (!block) continue;

        // Check if this block is a table
        const lines = block.split('\n');
        if (lines.length >= 2 &&
            lines[0].trim().startsWith('|') &&
            /^\|[\s\-:|]+\|?$/.test(lines[1].trim())) {
            htmlBlocks.push(convertTableToHtml(lines));
            continue;
        }

        // Check if this is a code block
        if (block.startsWith('```')) {
            const match = block.match(/```(\w*)\n([\s\S]*?)```/);
            if (match) {
                htmlBlocks.push(`<pre><code>${escapeHtml(match[2])}</code></pre>`);
                continue;
            }
        }

        // Check if this is a header
        const headerMatch = block.match(/^(#{1,6})\s+(.*)$/);
        if (headerMatch) {
            const level = headerMatch[1].length;
            htmlBlocks.push(`<h${level}>${parseInline(headerMatch[2])}</h${level}>`);
            continue;
        }

        // Check if this is a horizontal rule
        if (/^(-{3,}|\*{3,})$/.test(block)) {
            htmlBlocks.push('<hr>');
            continue;
        }

        // Check if this is a list
        if (/^[\*\-]\s/.test(block) || /^\d+\.\s/.test(block)) {
            const listItems = block.split('\n').map(line => {
                const content = line.replace(/^[\*\-]\s+/, '').replace(/^\d+\.\s+/, '');
                return `<li>${parseInline(content)}</li>`;
            }).join('');
            const listType = /^\d+\./.test(block) ? 'ol' : 'ul';
            htmlBlocks.push(`<${listType}>${listItems}</${listType}>`);
            continue;
        }

        // Check if this is a blockquote
        if (block.startsWith('>')) {
            const content = block.split('\n').map(line => line.replace(/^>\s*/, '')).join('<br>');
            htmlBlocks.push(`<blockquote>${parseInline(content)}</blockquote>`);
            continue;
        }

        // Regular paragraph - convert single newlines to <br>
        const paraContent = block.split('\n').map(line => parseInline(line)).join('<br>');
        htmlBlocks.push(`<p>${paraContent}</p>`);
    }

    return htmlBlocks.join('\n');
}

function escapeHtml(text) {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}

function parseInline(text) {
    return text
        // Bold and italic
        .replace(/\*\*\*([^*]+)\*\*\*/g, '<strong><em>$1</em></strong>')
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
        .replace(/___([^_]+)___/g, '<strong><em>$1</em></strong>')
        .replace(/__([^_]+)__/g, '<strong>$1</strong>')
        .replace(/_([^_]+)_/g, '<em>$1</em>')
        // Inline code
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        // Images: ![alt](src)
        .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">')
        // Links
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
}

function convertTableToHtml(tableLines) {
    if (tableLines.length < 2) return tableLines.join('\n');

    const parseRow = (line) => {
        // Remove leading/trailing pipes and split by |
        return line.trim().replace(/^\||\|$/g, '').split('|').map(cell => cell.trim());
    };

    const headerCells = parseRow(tableLines[0]);
    const alignments = parseRow(tableLines[1]).map(cell => {
        if (cell.startsWith(':') && cell.endsWith(':')) return 'center';
        if (cell.endsWith(':')) return 'right';
        return 'left';
    });

    let html = '<table>\n<thead>\n<tr>\n';
    headerCells.forEach((cell, idx) => {
        const align = alignments[idx] || 'left';
        html += `<th style="text-align: ${align}">${parseInline(cell)}</th>\n`;
    });
    html += '</tr>\n</thead>\n<tbody>\n';

    // Process body rows (skip header and separator)
    for (let i = 2; i < tableLines.length; i++) {
        const cells = parseRow(tableLines[i]);
        html += '<tr>\n';
        cells.forEach((cell, idx) => {
            const align = alignments[idx] || 'left';
            html += `<td style="text-align: ${align}">${parseInline(cell)}</td>\n`;
        });
        html += '</tr>\n';
    }

    html += '</tbody>\n</table>';
    return html;
}

// Content Editor State
let currentEditingNote = null;

function setupContentEditor() {
    const overlay = document.getElementById('contentEditorOverlay');
    const editor = overlay.querySelector('.content-editor');
    const header = overlay.querySelector('.content-editor-header');
    const textarea = document.getElementById('contentEditorTextarea');
    const preview = document.getElementById('contentEditorPreview');
    const titleSpan = document.getElementById('editorNoteTitle');
    const closeBtn = overlay.querySelector('.content-editor-close');
    const saveBtn = overlay.querySelector('.content-editor-save');
    const cancelBtn = overlay.querySelector('.content-editor-cancel');
    const resetBtn = overlay.querySelector('.content-editor-reset');
    const resizer = document.getElementById('editorResizer');
    const inputPane = overlay.querySelector('.content-editor-input');
    const previewPane = overlay.querySelector('.content-editor-preview');

    // Live preview
    textarea.addEventListener('input', () => {
        preview.innerHTML = parseMarkdown(textarea.value);
    });

    // Handle pasting images from clipboard
    textarea.addEventListener('paste', (e) => {
        const html = e.clipboardData?.getData('text/html');
        if (!html) return; // No HTML = likely screenshot, ignore

        // Extract image src from pasted HTML
        const match = html.match(/<img[^>]+src=["']([^"']+)["']/i);
        if (match && match[1]) {
            const imageUrl = match[1];
            // Skip data URLs (base64)
            if (imageUrl.startsWith('data:')) return;

            e.preventDefault();
            const cursorPos = textarea.selectionStart;
            const before = textarea.value.substring(0, cursorPos);
            const after = textarea.value.substring(textarea.selectionEnd);
            textarea.value = before + `![image](${imageUrl})` + after;
            textarea.selectionStart = textarea.selectionEnd = cursorPos + `![image](${imageUrl})`.length;
            textarea.dispatchEvent(new Event('input')); // Trigger preview update
        }
    });

    // Close button
    closeBtn.addEventListener('click', () => {
        overlay.classList.remove('open');
        currentEditingNote = null;
    });

    // Cancel button
    cancelBtn.addEventListener('click', () => {
        overlay.classList.remove('open');
        currentEditingNote = null;
    });

    // Save button
    saveBtn.addEventListener('click', () => {
        if (currentEditingNote) {
            const noteId = currentEditingNote;
            noteCustomizations[noteId] = noteCustomizations[noteId] || {};
            noteCustomizations[noteId].customContent = textarea.value;
            saveNoteCustomizations(noteCustomizations);

            // Update the note content
            const note = document.querySelector(`[data-note="${noteId}"]`);
            if (note) {
                const contentDiv = note.querySelector('.note-content');
                contentDiv.innerHTML = `<div class="markdown-content">${parseMarkdown(textarea.value)}</div>`;

                // Auto-resize note to fit new content
                requestAnimationFrame(() => {
                    autoFitNoteContent(note, false);
                });
            }
        }
        overlay.classList.remove('open');
        currentEditingNote = null;
    });

    // Reset button
    resetBtn.addEventListener('click', () => {
        if (currentEditingNote && confirm('Reset to default content? This will remove your custom content.')) {
            const noteId = currentEditingNote;
            if (noteCustomizations[noteId]) {
                delete noteCustomizations[noteId].customContent;
                saveNoteCustomizations(noteCustomizations);
            }

            // Restore default content
            const note = document.querySelector(`[data-note="${noteId}"]`);
            if (note) {
                const content = getNoteContent(noteId);
                const contentDiv = note.querySelector('.note-content');
                contentDiv.innerHTML = content.html;
            }

            overlay.classList.remove('open');
            currentEditingNote = null;
        }
    });

    // Close on overlay click
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            overlay.classList.remove('open');
            currentEditingNote = null;
        }
    });

    // Helper to get coords from mouse or touch event (local to this scope)
    function getCoords(e) {
        if (e.touches && e.touches.length > 0) {
            return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
        }
        if (e.changedTouches && e.changedTouches.length > 0) {
            return { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY };
        }
        return { clientX: e.clientX, clientY: e.clientY };
    }

    // Editor dragging
    let editorDrag = { isDragging: false, startX: 0, startY: 0, startLeft: 0, startTop: 0 };

    function startEditorDrag(e) {
        if (e.target.closest('.content-editor-close')) return;
        const coords = getCoords(e);
        editorDrag.isDragging = true;
        editorDrag.startX = coords.clientX;
        editorDrag.startY = coords.clientY;
        const rect = editor.getBoundingClientRect();
        editorDrag.startLeft = rect.left;
        editorDrag.startTop = rect.top;
        e.preventDefault();
    }

    header.addEventListener('mousedown', startEditorDrag);
    header.addEventListener('touchstart', startEditorDrag, { passive: false });

    function moveEditorDrag(e) {
        if (!editorDrag.isDragging) return;
        const coords = getCoords(e);
        const dx = coords.clientX - editorDrag.startX;
        const dy = coords.clientY - editorDrag.startY;
        const newLeft = Math.max(0, Math.min(window.innerWidth - editor.offsetWidth, editorDrag.startLeft + dx));
        const newTop = Math.max(0, Math.min(window.innerHeight - editor.offsetHeight, editorDrag.startTop + dy));
        editor.style.left = newLeft + 'px';
        editor.style.top = newTop + 'px';
    }

    document.addEventListener('mousemove', moveEditorDrag);
    document.addEventListener('touchmove', moveEditorDrag, { passive: false });

    function endEditorDrag() {
        editorDrag.isDragging = false;
    }

    document.addEventListener('mouseup', endEditorDrag);
    document.addEventListener('touchend', endEditorDrag);
    document.addEventListener('touchcancel', endEditorDrag);

    // Resizer for markdown/preview split
    let resizerState = { isResizing: false, startX: 0, startY: 0, startInputWidth: 0, startInputHeight: 0 };

    function startResizerDrag(e) {
        const coords = getCoords(e);
        resizerState.isResizing = true;
        resizerState.startX = coords.clientX;
        resizerState.startY = coords.clientY;
        resizerState.startInputWidth = inputPane.offsetWidth;
        resizerState.startInputHeight = inputPane.offsetHeight;
        resizer.classList.add('active');
        e.preventDefault();
    }

    resizer.addEventListener('mousedown', startResizerDrag);
    resizer.addEventListener('touchstart', startResizerDrag, { passive: false });

    function moveResizerDrag(e) {
        if (!resizerState.isResizing) return;
        const coords = getCoords(e);
        const editorBody = overlay.querySelector('.content-editor-body');

        // Check if we're in mobile vertical layout
        const isMobileLayout = window.innerWidth <= 768;

        if (isMobileLayout) {
            // Vertical resizing on mobile
            const dy = coords.clientY - resizerState.startY;
            const totalHeight = editorBody.offsetHeight - resizer.offsetHeight;
            const newInputHeight = Math.max(100, Math.min(totalHeight - 100, resizerState.startInputHeight + dy));
            const newPreviewHeight = totalHeight - newInputHeight;
            inputPane.style.flex = 'none';
            inputPane.style.height = newInputHeight + 'px';
            previewPane.style.flex = 'none';
            previewPane.style.height = newPreviewHeight + 'px';
        } else {
            // Horizontal resizing on desktop
            const dx = coords.clientX - resizerState.startX;
            const totalWidth = editorBody.offsetWidth - resizer.offsetWidth;
            const newInputWidth = Math.max(200, Math.min(totalWidth - 200, resizerState.startInputWidth + dx));
            const newPreviewWidth = totalWidth - newInputWidth;
            inputPane.style.flex = 'none';
            inputPane.style.width = newInputWidth + 'px';
            previewPane.style.flex = 'none';
            previewPane.style.width = newPreviewWidth + 'px';
        }
    }

    document.addEventListener('mousemove', moveResizerDrag);
    document.addEventListener('touchmove', moveResizerDrag, { passive: false });

    function endResizerDrag() {
        if (resizerState.isResizing) {
            resizerState.isResizing = false;
            resizer.classList.remove('active');
        }
    }

    document.addEventListener('mouseup', endResizerDrag);
    document.addEventListener('touchend', endResizerDrag);
    document.addEventListener('touchcancel', endResizerDrag);

    // Editor window resize
    let editorResize = { isResizing: false, handle: null, startX: 0, startY: 0, startWidth: 0, startHeight: 0 };

    editor.querySelectorAll('.content-editor-resize').forEach(handle => {
        function startEditorResize(e) {
            const coords = getCoords(e);
            editorResize.isResizing = true;
            editorResize.handle = handle.getAttribute('data-resize');
            editorResize.startX = coords.clientX;
            editorResize.startY = coords.clientY;
            editorResize.startWidth = editor.offsetWidth;
            editorResize.startHeight = editor.offsetHeight;
            e.preventDefault();
        }

        handle.addEventListener('mousedown', startEditorResize);
        handle.addEventListener('touchstart', startEditorResize, { passive: false });
    });

    function moveEditorResize(e) {
        if (!editorResize.isResizing) return;
        const coords = getCoords(e);
        const dx = coords.clientX - editorResize.startX;
        const dy = coords.clientY - editorResize.startY;

        if (editorResize.handle.includes('e')) {
            const newWidth = Math.max(500, editorResize.startWidth + dx);
            editor.style.width = newWidth + 'px';
        }
        if (editorResize.handle.includes('s')) {
            const newHeight = Math.max(300, editorResize.startHeight + dy);
            editor.style.height = newHeight + 'px';
        }
    }

    document.addEventListener('mousemove', moveEditorResize);
    document.addEventListener('touchmove', moveEditorResize, { passive: false });

    function endEditorResize() {
        editorResize.isResizing = false;
        editorResize.handle = null;
    }

    document.addEventListener('mouseup', endEditorResize);
    document.addEventListener('touchend', endEditorResize);
    document.addEventListener('touchcancel', endEditorResize);

    // Double-click on note content to edit
    const noteboard = document.getElementById('noteboard');
    noteboard.addEventListener('dblclick', (e) => {
        // Don't trigger on interactive elements
        if (e.target.closest('input, button, select, textarea, a, .checklist-widget, .calendar-widget, .diff-widget, .seq-widget')) return;

        const noteContent = e.target.closest('.note-content');
        if (!noteContent) return;

        const note = noteContent.closest('.note');
        if (!note) return;

        const noteId = note.getAttribute('data-note');
        if (noteId) {
            e.preventDefault();
            openContentEditor(noteId);
        }
    });
}

function openContentEditor(noteId) {
    const overlay = document.getElementById('contentEditorOverlay');
    const editor = overlay.querySelector('.content-editor');
    const textarea = document.getElementById('contentEditorTextarea');
    const preview = document.getElementById('contentEditorPreview');
    const titleSpan = document.getElementById('editorNoteTitle');
    const inputPane = overlay.querySelector('.content-editor-input');
    const previewPane = overlay.querySelector('.content-editor-preview');

    currentEditingNote = noteId;

    // Get note info
    const custom = noteCustomizations[noteId] || {};
    const content = getNoteContent(noteId);
    const displayTitle = custom.title || content.title;

    titleSpan.textContent = displayTitle;

    // Load existing custom content or convert default to markdown hint
    if (custom.customContent) {
        textarea.value = custom.customContent;
    } else {
        // Provide a hint with the note name
        textarea.value = `# ${content.title}\n\nEdit this content using Markdown.\n\n**Note:** The default dynamic content will be replaced with your custom content.`;
    }

    // Reset pane widths to default 50/50
    inputPane.style.flex = '1';
    inputPane.style.width = '';
    previewPane.style.flex = '1';
    previewPane.style.width = '';

    // Center the editor
    editor.style.left = '';
    editor.style.top = '';

    preview.innerHTML = parseMarkdown(textarea.value);
    overlay.classList.add('open');

    // Center after opening (when dimensions are known)
    requestAnimationFrame(() => {
        const editorRect = editor.getBoundingClientRect();
        editor.style.left = (window.innerWidth - editorRect.width) / 2 + 'px';
        editor.style.top = (window.innerHeight - editorRect.height) / 2 + 'px';
    });

    textarea.focus();
}

// Noteboard settings
const DASHBOARD_COLORS = [
    '#2c3e50', '#34495e', '#1a252f', '#2980b9', '#3498db',
    '#8e44ad', '#9b59b6', '#16a085', '#1abc9c', '#27ae60',
    '#d35400', '#e67e22', '#c0392b', '#e74c3c', '#7f8c8d'
];

function loadNoteboardSettings() {
    const stored = localStorage.getItem(boardKey('noteboardSettings'));
    if (stored) {
        try {
            return JSON.parse(stored);
        } catch (e) {
            return { title: 'My Toolboard', color: '#2c3e50' };
        }
    }
    return { title: 'My Toolboard', color: '#2c3e50' };
}

function saveNoteboardSettings(settings) {
    localStorage.setItem(boardKey('noteboardSettings'), JSON.stringify(settings));
}

let noteboardSettings = loadNoteboardSettings();

function applyNoteboardSettings() {
    const header = document.getElementById('mainHeader');
    const title = document.getElementById('noteboardTitle');
    const titleInput = document.getElementById('noteboardTitleInput');
    const colorPicker = document.getElementById('noteboardColorPicker');

    title.textContent = noteboardSettings.title;
    header.style.background = noteboardSettings.color;
    titleInput.value = noteboardSettings.title;

    // Update browser tab title
    document.title = noteboardSettings.title + ' - Toolboard';

    // Populate color picker
    colorPicker.innerHTML = DASHBOARD_COLORS.map(c =>
        `<div class="color-swatch${noteboardSettings.color === c ? ' selected' : ''}" style="background: ${c}" data-color="${c}"></div>`
    ).join('');
}

function setupNoteboardSettings() {
    const settingsBtn = document.getElementById('noteboardSettingsBtn');
    const settingsPanel = document.getElementById('noteboardSettings');
    const titleInput = document.getElementById('noteboardTitleInput');
    const colorPicker = document.getElementById('noteboardColorPicker');
    const header = document.getElementById('mainHeader');
    const title = document.getElementById('noteboardTitle');

    // Toggle settings panel
    settingsBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        // Close note settings modal
        document.getElementById('noteSettingsOverlay').classList.remove('open');
        settingsPanel.classList.toggle('open');
    });

    // Title input
    titleInput.addEventListener('input', (e) => {
        noteboardSettings.title = e.target.value;
        title.textContent = e.target.value;
        saveNoteboardSettings(noteboardSettings);
        // Update board name to match noteboard title
        renameBoardInSelector();
    });

    // Color picker
    colorPicker.addEventListener('click', (e) => {
        if (e.target.classList.contains('color-swatch')) {
            const color = e.target.getAttribute('data-color');
            noteboardSettings.color = color;
            header.style.background = color;
            colorPicker.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
            e.target.classList.add('selected');
            saveNoteboardSettings(noteboardSettings);
        }
    });

    // Close when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.noteboard-settings') && !e.target.closest('#noteboardSettingsBtn')) {
            settingsPanel.classList.remove('open');
        }
    });
}

// Available colors for note headers
const HEADER_COLORS = [
    '#8e44ad', '#9b59b6', '#3498db', '#2980b9', '#1abc9c',
    '#16a085', '#27ae60', '#2ecc71', '#f39c12', '#e67e22',
    '#d35400', '#e74c3c', '#c0392b', '#34495e', '#7f8c8d'
];

// Load note customizations
function loadNoteCustomizations() {
    const stored = localStorage.getItem(boardKey('noteCustomizations'));
    if (stored) {
        try {
            return JSON.parse(stored);
        } catch (e) {
            return {};
        }
    }
    return {};
}

// Save note customizations
function saveNoteCustomizations(customizations) {
    localStorage.setItem(boardKey('noteCustomizations'), JSON.stringify(customizations));
}

// Custom notes storage
function loadCustomNotes() {
    const stored = localStorage.getItem(boardKey('customNotes'));
    if (stored) {
        try {
            return JSON.parse(stored);
        } catch (e) {
            return [];
        }
    }
    return [];
}

function saveCustomNotes(notes) {
    localStorage.setItem(boardKey('customNotes'), JSON.stringify(notes));
}

// Hidden notes storage (for built-in notes that have been deleted)
function loadHiddenNotes() {
    const stored = localStorage.getItem(boardKey('hiddenNotes'));
    if (stored) {
        try {
            return JSON.parse(stored);
        } catch (e) {
            return [];
        }
    }
    return [];
}

function saveHiddenNotes(notes) {
    localStorage.setItem(boardKey('hiddenNotes'), JSON.stringify(notes));
}

let noteCustomizations = loadNoteCustomizations();
let customNotes = loadCustomNotes();
let hiddenNotes = loadHiddenNotes();

// Create a note element
function createNote(noteId) {
    const note = document.createElement('div');
    note.className = 'note';
    note.setAttribute('data-note', noteId);

    const content = getNoteContent(noteId);
    if (!content) return null;

    // Get customizations for this note
    const custom = noteCustomizations[noteId] || {};
    const displayTitle = custom.title || content.title;
    const headerColor = custom.color || null;
    const isMinimized = custom.minimized || false;
    const isCustomNote = customNotes.includes(noteId);

    note.innerHTML = `
        <div class="note-header"${headerColor ? ` style="background: ${headerColor}"` : ''}>
            <span class="note-title">${displayTitle}</span>
            <div class="header-buttons">
                <button class="header-btn minimize-btn${isMinimized ? ' minimized' : ''}" title="Minimize">&#9650;</button>
                <button class="header-btn fullscreen-btn" title="Fullscreen"><svg width="12" height="12" viewBox="0 0 12 12" fill="currentColor"><rect x="0" y="0" width="12" height="12" rx="1" stroke="currentColor" stroke-width="2" fill="none"/></svg></button>
                <button class="header-btn settings-btn" title="Settings">&#9881;</button>
            </div>
        </div>
        <div class="note-content">
            ${custom.customContent ? `<div class="markdown-content">${parseMarkdown(custom.customContent)}</div>` : content.html}
        </div>
        <div class="resize-handle resize-handle-n" data-resize="n"></div>
        <div class="resize-handle resize-handle-s" data-resize="s"></div>
        <div class="resize-handle resize-handle-e" data-resize="e"></div>
        <div class="resize-handle resize-handle-w" data-resize="w"></div>
        <div class="resize-handle resize-handle-nw" data-resize="nw"></div>
        <div class="resize-handle resize-handle-ne" data-resize="ne"></div>
        <div class="resize-handle resize-handle-sw" data-resize="sw"></div>
        <div class="resize-handle resize-handle-se" data-resize="se"></div>
    `;

    // Apply minimized state
    if (isMinimized) {
        note.classList.add('minimized');
    }

    // Apply position and size
    const pos = positions[noteId] || { x: 20, y: 20, z: 1 };
    note.style.left = pos.x + 'px';
    note.style.top = pos.y + 'px';
    note.style.zIndex = pos.z || 1;

    // Apply saved dimensions if they exist
    if (pos.width) {
        note.style.width = pos.width + 'px';
    }
    if (pos.height) {
        note.style.height = pos.height + 'px';
    }

    return note;
}

// Get content for each note
function getNoteContent(noteId) {
    // All notes are custom notes in the generic noteboard
    if (customNotes.includes(noteId)) {
        const custom = noteCustomizations[noteId] || {};

        // Check if this note uses a template with HTML content
        if (custom.templateId && NOTE_TEMPLATES[custom.templateId]) {
            const template = NOTE_TEMPLATES[custom.templateId];
            const isHtml = template.content.trim().startsWith('<');
            if (isHtml) {
                return {
                    title: custom.title || template.title,
                    html: template.content
                };
            }
        }

        return {
            title: custom.title || 'New Note',
            html: custom.customContent ? `<div class="markdown-content">${parseMarkdown(custom.customContent)}</div>` : '<p>Click the settings gear and "Edit Content" to add content to this note.</p>'
        };
    }
    return null;
}

// Helper to get coordinates from mouse or touch event
function getEventCoords(e) {
    if (e.touches && e.touches.length > 0) {
        return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
    }
    if (e.changedTouches && e.changedTouches.length > 0) {
        return { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY };
    }
    return { clientX: e.clientX, clientY: e.clientY };
}

// Free-form Drag functionality
function setupDragging() {
    const noteboard = document.getElementById('noteboard');

    // Start drag handler (mouse and touch)
    function startDrag(e) {
        const header = e.target.closest('.note-header');
        if (!header) return;

        // Don't drag if clicking buttons
        if (e.target.closest('.header-btn')) return;

        const note = header.closest('.note');
        if (!note) return;

        e.preventDefault();

        const coords = getEventCoords(e);

        // Bring to front
        maxZ++;
        note.style.zIndex = maxZ;

        const noteId = note.getAttribute('data-note');
        positions[noteId] = positions[noteId] || { x: 0, y: 0, z: 1 };
        positions[noteId].z = maxZ;

        // Start dragging
        dragState.isDragging = true;
        dragState.note = note;
        dragState.startX = coords.clientX;
        dragState.startY = coords.clientY;
        dragState.offsetX = note.offsetLeft;
        dragState.offsetY = note.offsetTop;

        note.classList.add('dragging');
        document.body.classList.add('is-dragging');
    }

    // Mouse/touch down on note header starts drag
    noteboard.addEventListener('mousedown', startDrag);
    noteboard.addEventListener('touchstart', startDrag, { passive: false });

    // Move handler (mouse and touch)
    function moveDrag(e) {
        if (!dragState.isDragging) return;

        const coords = getEventCoords(e);
        const dx = coords.clientX - dragState.startX;
        const dy = coords.clientY - dragState.startY;

        let newX = Math.max(0, dragState.offsetX + dx);
        let newY = Math.max(0, dragState.offsetY + dy);

        // Get snap positions
        const snapped = getSnapPosition(dragState.note, newX, newY);
        newX = snapped.x;
        newY = snapped.y;

        dragState.note.style.left = newX + 'px';
        dragState.note.style.top = newY + 'px';

        // Show/hide snap guides
        updateSnapGuides(snapped.guides);
    }

    // Mouse/touch move updates position with snapping
    document.addEventListener('mousemove', moveDrag);
    document.addEventListener('touchmove', moveDrag, { passive: false });

    // End drag handler (mouse and touch)
    function endDrag() {
        if (!dragState.isDragging) return;

        const note = dragState.note;
        const noteId = note.getAttribute('data-note');

        // Save position (preserve existing width/height if set)
        const existing = positions[noteId] || {};
        positions[noteId] = {
            x: note.offsetLeft,
            y: note.offsetTop,
            z: parseInt(note.style.zIndex) || 1,
            width: existing.width || note.offsetWidth,
            height: existing.height || note.offsetHeight
        };
        savePositions(positions);

        note.classList.remove('dragging');
        document.body.classList.remove('is-dragging');
        dragState.isDragging = false;
        dragState.note = null;

        // Hide snap guides
        updateSnapGuides([]);
    }

    // Mouse/touch up ends drag and saves position
    document.addEventListener('mouseup', endDrag);
    document.addEventListener('touchend', endDrag);
    document.addEventListener('touchcancel', endDrag);

    // Click on note brings it to front
    noteboard.addEventListener('mousedown', (e) => {
        const note = e.target.closest('.note');
        if (!note) return;

        // Only bring to front if not clicking header (header handles its own)
        if (!e.target.closest('.note-header')) {
            maxZ++;
            note.style.zIndex = maxZ;
            const noteId = note.getAttribute('data-note');
            positions[noteId] = positions[noteId] || { x: note.offsetLeft, y: note.offsetTop, z: 1 };
            positions[noteId].z = maxZ;
            savePositions(positions);
        }
    });
}

// Resize functionality
function setupResizing() {
    const noteboard = document.getElementById('noteboard');

    // Double-click/double-tap on resize handle for auto-resize
    noteboard.addEventListener('dblclick', (e) => {
        const handle = e.target.closest('.resize-handle');
        if (!handle) return;

        const note = handle.closest('.note');
        if (!note) return;

        e.preventDefault();
        e.stopPropagation();

        const handleType = handle.getAttribute('data-resize');
        autoResizeNote(note, handleType);
    });

    // Start resize handler (mouse and touch)
    function startResize(e) {
        const handle = e.target.closest('.resize-handle');
        if (!handle) return;

        const note = handle.closest('.note');
        if (!note) return;

        e.preventDefault();
        e.stopPropagation();

        const coords = getEventCoords(e);

        // Bring to front
        maxZ++;
        note.style.zIndex = maxZ;

        const noteId = note.getAttribute('data-note');
        positions[noteId] = positions[noteId] || { x: 0, y: 0, z: 1 };
        positions[noteId].z = maxZ;

        // Start resizing
        resizeState.isResizing = true;
        resizeState.note = note;
        resizeState.handle = handle.getAttribute('data-resize');
        resizeState.startX = coords.clientX;
        resizeState.startY = coords.clientY;
        resizeState.startWidth = note.offsetWidth;
        resizeState.startHeight = note.offsetHeight;
        resizeState.startLeft = note.offsetLeft;
        resizeState.startTop = note.offsetTop;

        handle.classList.add('active');
        note.classList.add('resizing');
        document.body.classList.add('is-resizing');
    }

    // Mouse/touch down on resize handle starts resize
    noteboard.addEventListener('mousedown', startResize);
    noteboard.addEventListener('touchstart', startResize, { passive: false });

    // Move resize handler (mouse and touch)
    function moveResize(e) {
        if (!resizeState.isResizing) return;

        const coords = getEventCoords(e);
        const dx = coords.clientX - resizeState.startX;
        const dy = coords.clientY - resizeState.startY;
        const note = resizeState.note;
        const handle = resizeState.handle;

        let newWidth = resizeState.startWidth;
        let newHeight = resizeState.startHeight;
        let newLeft = resizeState.startLeft;
        let newTop = resizeState.startTop;

        const minWidth = 150;
        const minHeight = 100;

        // Handle resize based on which handle is being dragged
        if (handle.includes('e')) {
            newWidth = Math.max(minWidth, resizeState.startWidth + dx);
        }
        if (handle.includes('w')) {
            const proposedWidth = resizeState.startWidth - dx;
            if (proposedWidth >= minWidth) {
                newWidth = proposedWidth;
                newLeft = resizeState.startLeft + dx;
            }
        }
        if (handle.includes('s')) {
            newHeight = Math.max(minHeight, resizeState.startHeight + dy);
        }
        if (handle.includes('n')) {
            const proposedHeight = resizeState.startHeight - dy;
            if (proposedHeight >= minHeight) {
                newHeight = proposedHeight;
                newTop = resizeState.startTop + dy;
            }
        }

        // Apply snapping for resize edges
        const snapped = getResizeSnapPosition(note, newLeft, newTop, newWidth, newHeight, handle);

        note.style.width = snapped.width + 'px';
        note.style.height = snapped.height + 'px';
        note.style.left = snapped.left + 'px';
        note.style.top = snapped.top + 'px';

        updateSnapGuides(snapped.guides);
    }

    // Mouse/touch move updates size
    document.addEventListener('mousemove', moveResize);
    document.addEventListener('touchmove', moveResize, { passive: false });

    // End resize handler (mouse and touch)
    function endResize() {
        if (!resizeState.isResizing) return;

        const note = resizeState.note;
        const noteId = note.getAttribute('data-note');

        // Save position and dimensions
        positions[noteId] = {
            x: note.offsetLeft,
            y: note.offsetTop,
            z: parseInt(note.style.zIndex) || 1,
            width: note.offsetWidth,
            height: note.offsetHeight
        };
        savePositions(positions);

        // Clean up
        document.querySelectorAll('.resize-handle.active').forEach(h => h.classList.remove('active'));
        note.classList.remove('resizing');
        document.body.classList.remove('is-resizing');
        resizeState.isResizing = false;
        resizeState.note = null;
        resizeState.handle = null;

        updateSnapGuides([]);
    }

    // Mouse/touch up ends resize and saves dimensions
    document.addEventListener('mouseup', endResize);
    document.addEventListener('touchend', endResize);
    document.addEventListener('touchcancel', endResize);
}

// Auto-fit note to its content (used on initial render)
function autoFitNoteContent(note, skipAnimation = false) {
    const noteId = note.getAttribute('data-note');
    const content = note.querySelector('.note-content');
    const header = note.querySelector('.note-header');

    if (!content || !header) return;

    // Temporarily remove constraints to measure natural size
    const originalWidth = note.style.width;
    const originalHeight = note.style.height;
    note.style.width = 'auto';
    note.style.height = 'auto';
    content.style.overflow = 'visible';

    // Force reflow
    note.offsetHeight;

    // Measure natural dimensions with reasonable bounds
    const newWidth = Math.max(200, Math.min(600, content.scrollWidth + 30));
    const newHeight = Math.max(120, Math.min(500, content.scrollHeight + header.offsetHeight + 20));

    // Restore overflow
    content.style.overflow = '';

    // Apply dimensions
    if (!skipAnimation) {
        note.style.transition = 'width 0.2s ease, height 0.2s ease';
    }

    note.style.width = newWidth + 'px';
    note.style.height = newHeight + 'px';

    if (!skipAnimation) {
        setTimeout(() => {
            note.style.transition = '';
        }, 200);
    }

    // Save dimensions
    const existing = positions[noteId] || { x: note.offsetLeft, y: note.offsetTop, z: 1 };
    positions[noteId] = {
        x: existing.x,
        y: existing.y,
        z: existing.z,
        width: newWidth,
        height: newHeight
    };
    savePositions(positions);
}

// Auto-resize note to fit content
function autoResizeNote(note, handleType) {
    const noteId = note.getAttribute('data-note');
    const content = note.querySelector('.note-content');
    const header = note.querySelector('.note-header');

    // Determine which dimensions to auto-resize
    const autoWidth = handleType.includes('e') || handleType.includes('w');
    const autoHeight = handleType.includes('s') || handleType.includes('n');

    // Store current dimensions
    const currentWidth = note.style.width;
    const currentHeight = note.style.height;

    // Temporarily remove constraints to measure natural size
    if (autoWidth) {
        note.style.width = 'auto';
        content.style.overflow = 'visible';
    }
    if (autoHeight) {
        note.style.height = 'auto';
        content.style.overflow = 'visible';
    }

    // Force reflow
    note.offsetHeight;

    // Measure natural dimensions
    let newWidth = note.offsetWidth;
    let newHeight = note.offsetHeight;

    // Add some padding for comfortable viewing
    if (autoWidth) {
        newWidth = Math.max(150, Math.min(800, content.scrollWidth + 30));
    }
    if (autoHeight) {
        newHeight = Math.max(100, Math.min(600, content.scrollHeight + header.offsetHeight + 10));
    }

    // Restore overflow
    content.style.overflow = '';

    // Apply new dimensions with animation
    note.style.transition = 'width 0.2s ease, height 0.2s ease';

    if (autoWidth) {
        note.style.width = newWidth + 'px';
    } else {
        note.style.width = currentWidth;
    }

    if (autoHeight) {
        note.style.height = newHeight + 'px';
    } else {
        note.style.height = currentHeight;
    }

    // Remove transition after animation
    setTimeout(() => {
        note.style.transition = '';
    }, 200);

    // Save new dimensions
    const existing = positions[noteId] || { x: note.offsetLeft, y: note.offsetTop, z: 1 };
    positions[noteId] = {
        x: existing.x,
        y: existing.y,
        z: existing.z,
        width: autoWidth ? newWidth : (existing.width || note.offsetWidth),
        height: autoHeight ? newHeight : (existing.height || note.offsetHeight)
    };
    savePositions(positions);
}

// Snapping for resize operations
function getResizeSnapPosition(note, left, top, width, height, handle) {
    const noteboard = document.getElementById('noteboard');
    const notes = noteboard.querySelectorAll('.note');

    const right = left + width;
    const bottom = top + height;

    let snapLeft = left;
    let snapTop = top;
    let snapWidth = width;
    let snapHeight = height;
    const guides = [];

    // Collect edges from other notes
    const verticalEdges = [0];
    const horizontalEdges = [0];

    notes.forEach(s => {
        if (s === note) return;

        const sLeft = s.offsetLeft;
        const sTop = s.offsetTop;
        const sRight = sLeft + s.offsetWidth;
        const sBottom = sTop + s.offsetHeight;

        verticalEdges.push(sLeft, sRight);
        horizontalEdges.push(sTop, sBottom);
    });

    // Snap right edge (when resizing east)
    if (handle.includes('e')) {
        for (const edge of verticalEdges) {
            if (Math.abs(right - edge) < SNAP_THRESHOLD) {
                snapWidth = edge - left;
                guides.push({ type: 'vertical', pos: edge });
                break;
            }
        }
    }

    // Snap left edge (when resizing west)
    if (handle.includes('w')) {
        for (const edge of verticalEdges) {
            if (Math.abs(left - edge) < SNAP_THRESHOLD) {
                const diff = left - edge;
                snapLeft = edge;
                snapWidth = width + diff;
                guides.push({ type: 'vertical', pos: edge });
                break;
            }
        }
    }

    // Snap bottom edge (when resizing south)
    if (handle.includes('s')) {
        for (const edge of horizontalEdges) {
            if (Math.abs(bottom - edge) < SNAP_THRESHOLD) {
                snapHeight = edge - top;
                guides.push({ type: 'horizontal', pos: edge });
                break;
            }
        }
    }

    // Snap top edge (when resizing north)
    if (handle.includes('n')) {
        for (const edge of horizontalEdges) {
            if (Math.abs(top - edge) < SNAP_THRESHOLD) {
                const diff = top - edge;
                snapTop = edge;
                snapHeight = height + diff;
                guides.push({ type: 'horizontal', pos: edge });
                break;
            }
        }
    }

    return {
        left: Math.max(0, snapLeft),
        top: Math.max(0, snapTop),
        width: Math.max(150, snapWidth),
        height: Math.max(100, snapHeight),
        guides
    };
}

// Snapping functionality
function getSnapPosition(draggedNote, x, y) {
    const noteboard = document.getElementById('noteboard');
    const notes = noteboard.querySelectorAll('.note');
    const width = draggedNote.offsetWidth;
    const height = draggedNote.offsetHeight;

    // Dragged note edges
    const dragLeft = x;
    const dragRight = x + width;
    const dragTop = y;
    const dragBottom = y + height;

    let snapX = x;
    let snapY = y;
    let bestDiffX = SNAP_THRESHOLD;
    let bestDiffY = SNAP_THRESHOLD;
    const guides = [];

    // Collect all edges from other notes
    const verticalEdges = [0]; // Noteboard left edge
    const horizontalEdges = [0]; // Noteboard top edge

    notes.forEach(note => {
        if (note === draggedNote) return;

        const left = note.offsetLeft;
        const top = note.offsetTop;
        const right = left + note.offsetWidth;
        const bottom = top + note.offsetHeight;

        verticalEdges.push(left, right);
        horizontalEdges.push(top, bottom);
    });

    // Find best vertical snap (X position)
    for (const edge of verticalEdges) {
        // Snap left edge of dragged to this edge
        const diffLeft = Math.abs(dragLeft - edge);
        if (diffLeft < bestDiffX) {
            bestDiffX = diffLeft;
            snapX = edge;
        }

        // Snap right edge of dragged to this edge
        const diffRight = Math.abs(dragRight - edge);
        if (diffRight < bestDiffX) {
            bestDiffX = diffRight;
            snapX = edge - width;
        }
    }

    // Find best horizontal snap (Y position)
    for (const edge of horizontalEdges) {
        // Snap top edge of dragged to this edge
        const diffTop = Math.abs(dragTop - edge);
        if (diffTop < bestDiffY) {
            bestDiffY = diffTop;
            snapY = edge;
        }

        // Snap bottom edge of dragged to this edge
        const diffBottom = Math.abs(dragBottom - edge);
        if (diffBottom < bestDiffY) {
            bestDiffY = diffBottom;
            snapY = edge - height;
        }
    }

    // Add guides for snapped edges
    if (bestDiffX < SNAP_THRESHOLD) {
        // Determine which edge we snapped to
        const snappedEdge = (snapX === x) ? snapX : snapX + width;
        guides.push({ type: 'vertical', pos: snappedEdge });
    }

    if (bestDiffY < SNAP_THRESHOLD) {
        const snappedEdge = (snapY === y) ? snapY : snapY + height;
        guides.push({ type: 'horizontal', pos: snappedEdge });
    }

    return { x: Math.max(0, snapX), y: Math.max(0, snapY), guides };
}

function updateSnapGuides(guides) {
    // Remove existing guides
    document.querySelectorAll('.snap-guide').forEach(el => el.remove());

    if (guides.length === 0) return;

    const noteboard = document.getElementById('noteboard');

    guides.forEach(guide => {
        const el = document.createElement('div');
        el.className = 'snap-guide';

        if (guide.type === 'vertical') {
            el.style.cssText = `
                position: absolute;
                left: ${guide.pos}px;
                top: 0;
                width: 2px;
                height: 100%;
                background: #3498db;
                pointer-events: none;
                z-index: 9999;
            `;
        } else {
            el.style.cssText = `
                position: absolute;
                left: 0;
                top: ${guide.pos}px;
                width: 100%;
                height: 2px;
                background: #3498db;
                pointer-events: none;
                z-index: 9999;
            `;
        }

        noteboard.appendChild(el);
    });
}

// Import/Export functionality
function setupImportExport() {
    const modal = document.getElementById('importExportModal');
    const closeBtn = modal.querySelector('.import-export-close');
    const tabs = modal.querySelectorAll('.import-export-tab');
    const exportNote = document.getElementById('exportNote');
    const importNote = document.getElementById('importNote');

    // Open modal
    document.getElementById('importExportBtn').onclick = () => {
        populateExportLists();
        modal.classList.add('open');
    };

    // Close modal
    closeBtn.onclick = () => modal.classList.remove('open');
    modal.onclick = (e) => {
        if (e.target === modal) modal.classList.remove('open');
    };

    const restoreNote = document.getElementById('restoreNote');

    // Tab switching
    tabs.forEach(tab => {
        tab.onclick = () => {
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            exportNote.classList.remove('active');
            importNote.classList.remove('active');
            restoreNote.classList.remove('active');

            if (tab.dataset.tab === 'export') {
                exportNote.classList.add('active');
            } else if (tab.dataset.tab === 'import') {
                importNote.classList.add('active');
            } else if (tab.dataset.tab === 'restore') {
                restoreNote.classList.add('active');
                populateHiddenNotesList();
            }
        };
    });

    // Export buttons
    document.getElementById('exportSelectedNotes').onclick = exportNotes;
    document.getElementById('exportSelectedBoards').onclick = exportBoards;
    document.getElementById('exportBoardAsHTML').onclick = exportBoardAsHTML;
    document.getElementById('exportBoardAsPNG').onclick = exportBoardAsPNG;

    // Import
    document.getElementById('importDataBtn').onclick = importData;
    document.getElementById('importFileInput').onchange = handleFileImport;

    // Restore
    document.getElementById('restoreSelectedNotes').onclick = restoreSelectedNotes;
}

// Feature Selection Modal
function setupFeatureSelect() {
    const modal = document.getElementById('featureSelectModal');
    const closeBtn = modal.querySelector('.feature-select-close');
    const list = document.getElementById('featureSelectList');

    // Close modal
    closeBtn.onclick = () => modal.classList.remove('open');
    modal.onclick = (e) => {
        if (e.target === modal) modal.classList.remove('open');
    };

    // Populate list
    populateFeatureList();

    // Handle feature selection
    list.addEventListener('click', (e) => {
        const item = e.target.closest('.feature-select-item');
        if (!item) return;

        const templateId = item.getAttribute('data-template');
        modal.classList.remove('open');
        createNoteWithTemplate(templateId);
    });
}

function populateFeatureList() {
    const list = document.getElementById('featureSelectList');
    list.innerHTML = Object.values(NOTE_TEMPLATES).map(template => `
        <div class="feature-select-item" data-template="${template.id}">
            <div class="feature-select-icon">${template.icon}</div>
            <div class="feature-select-info">
                <div class="feature-select-name">${template.name}</div>
                <div class="feature-select-description">${template.description}</div>
            </div>
        </div>
    `).join('');
}

function openFeatureSelectModal() {
    const modal = document.getElementById('featureSelectModal');
    modal.classList.add('open');
}

function createNoteWithTemplate(templateId) {
    const template = NOTE_TEMPLATES[templateId];
    if (!template) return;

    // Generate unique ID
    const noteId = 'custom-' + Date.now();

    // Add to custom notes list
    customNotes.push(noteId);
    saveCustomNotes(customNotes);

    // Determine if content is HTML or Markdown
    const isHtml = template.content.trim().startsWith('<');

    // Initialize customizations with template content
    noteCustomizations[noteId] = {
        title: template.title,
        templateId: templateId, // Store template ID for HTML templates
        customContent: isHtml ? '' : template.content // Only store markdown in customContent
    };
    saveNoteCustomizations(noteCustomizations);

    // Create and add the note to the noteboard
    const note = createNote(noteId);
    if (note) {
        const noteboard = document.getElementById('noteboard');
        noteboard.appendChild(note);

        // Position it in a visible area with slight offset from others
        const offset = customNotes.length * 20;
        note.style.left = (100 + offset) + 'px';
        note.style.top = (100 + offset) + 'px';

        // Bring to front
        maxZ++;
        note.style.zIndex = maxZ;

        // Auto-fit note to content after DOM is ready
        requestAnimationFrame(() => {
            autoFitNoteContent(note, false);

            // Update position with auto-fit dimensions
            positions[noteId] = {
                x: 100 + offset,
                y: 100 + offset,
                width: note.offsetWidth,
                height: note.offsetHeight,
                z: maxZ
            };
            savePositions(positions);
        });

        // Call onInit if specified
        if (template.onInit && typeof window[template.onInit] === 'function') {
            setTimeout(() => window[template.onInit](), 50);
        }

        // For blank notes, open the content editor immediately
        if (templateId === 'blank') {
            openContentEditor(noteId);
        }
    }
}

function populateExportLists() {
    // Populate notes list (exclude hidden notes)
    const notesList = document.getElementById('exportNotesList');
    const visibleBuiltIn = SECTIONS.filter(id => !hiddenNotes.includes(id));
    const allNotes = [...visibleBuiltIn, ...customNotes];

    notesList.innerHTML = `
        <label class="select-all-row">
            <input type="checkbox" id="selectAllNotes"> <strong>Select All</strong>
        </label>
        ${allNotes.map(noteId => {
            const custom = noteCustomizations[noteId] || {};
            const content = getNoteContent(noteId);
            const title = custom.title || (content ? content.title : noteId);
            const isCustom = customNotes.includes(noteId);
            return `<label>
                <input type="checkbox" class="note-checkbox" value="${noteId}">
                ${title}${isCustom ? ' <em>(custom)</em>' : ''}
            </label>`;
        }).join('')}
    `;

    // Select all for notes
    document.getElementById('selectAllNotes').onchange = (e) => {
        notesList.querySelectorAll('.note-checkbox').forEach(cb => {
            cb.checked = e.target.checked;
        });
    };

    // Populate boards list
    const boardsList = document.getElementById('exportBoardsList');
    boardsList.innerHTML = `
        <label class="select-all-row">
            <input type="checkbox" id="selectAllBoards"> <strong>Select All</strong>
        </label>
        ${boards.map(board => `<label>
            <input type="checkbox" class="board-checkbox" value="${board.id}"${board.id === currentBoardId ? ' checked' : ''}>
            ${board.name}${board.id === currentBoardId ? ' <em>(current)</em>' : ''}
        </label>`).join('')}
    `;

    // Select all for boards
    document.getElementById('selectAllBoards').onchange = (e) => {
        boardsList.querySelectorAll('.board-checkbox').forEach(cb => {
            cb.checked = e.target.checked;
        });
    };
}

function populateHiddenNotesList() {
    const list = document.getElementById('hiddenNotesList');
    const resultDiv = document.getElementById('restoreResult');
    resultDiv.innerHTML = '';

    if (hiddenNotes.length === 0) {
        list.innerHTML = '<p style="color: #7f8c8d; padding: 10px;">No hidden notes. All built-in notes are visible.</p>';
        return;
    }

    list.innerHTML = `
        <label class="select-all-row">
            <input type="checkbox" id="selectAllHidden"> <strong>Select All</strong>
        </label>
        ${hiddenNotes.map(noteId => {
            const content = getNoteContent(noteId);
            const title = content ? content.title : noteId;
            return `<label>
                <input type="checkbox" class="hidden-note-checkbox" value="${noteId}">
                ${title}
            </label>`;
        }).join('')}
    `;

    document.getElementById('selectAllHidden').onchange = (e) => {
        list.querySelectorAll('.hidden-note-checkbox').forEach(cb => {
            cb.checked = e.target.checked;
        });
    };
}

function restoreSelectedNotes() {
    const checkboxes = document.querySelectorAll('.hidden-note-checkbox:checked');
    const resultDiv = document.getElementById('restoreResult');

    if (checkboxes.length === 0) {
        alert('Please select at least one note to restore.');
        return;
    }

    const notesToRestore = [];
    checkboxes.forEach(cb => {
        notesToRestore.push(cb.value);
    });

    // Remove from hidden notes
    hiddenNotes = hiddenNotes.filter(id => !notesToRestore.includes(id));
    saveHiddenNotes(hiddenNotes);

    // Refresh UI
    renderNoteboard();
    populateHiddenNotesList();
    populateExportLists();

    resultDiv.className = 'import-result success';
    resultDiv.textContent = `Successfully restored ${notesToRestore.length} note(s).`;
}

function exportNotes() {
    const checkboxes = document.querySelectorAll('.note-checkbox:checked');
    if (checkboxes.length === 0) {
        alert('Please select at least one note to export.');
        return;
    }

    const exportData = {
        type: 'notes',
        exportedAt: new Date().toISOString(),
        notes: []
    };

    checkboxes.forEach(cb => {
        const noteId = cb.value;
        const noteData = {
            id: noteId,
            isCustom: customNotes.includes(noteId),
            customizations: noteCustomizations[noteId] || {},
            position: positions[noteId] || null
        };
        exportData.notes.push(noteData);
    });

    downloadJSON(exportData, `notes-export-${getTimestamp()}.json`);
}

function exportBoards() {
    const checkboxes = document.querySelectorAll('.board-checkbox:checked');
    if (checkboxes.length === 0) {
        alert('Please select at least one board to export.');
        return;
    }

    const exportData = {
        type: 'boards',
        exportedAt: new Date().toISOString(),
        boards: []
    };

    checkboxes.forEach(cb => {
        const boardId = cb.value;
        const board = boards.find(b => b.id === boardId);

        // Get board-specific data
        const boardData = {
            id: boardId,
            name: board.name,
            variables: JSON.parse(localStorage.getItem(`finance_${boardId}_variables`) || 'null'),
            positions: JSON.parse(localStorage.getItem(`finance_${boardId}_positions`) || '{}'),
            noteCustomizations: JSON.parse(localStorage.getItem(`finance_${boardId}_noteCustomizations`) || '{}'),
            customNotes: JSON.parse(localStorage.getItem(`finance_${boardId}_customNotes`) || '[]'),
            hiddenNotes: JSON.parse(localStorage.getItem(`finance_${boardId}_hiddenNotes`) || '[]'),
            noteboardSettings: JSON.parse(localStorage.getItem(`finance_${boardId}_noteboardSettings`) || 'null')
        };

        exportData.boards.push(boardData);
    });

    downloadJSON(exportData, `boards-export-${getTimestamp()}.json`);
}

function getTimestamp() {
    const now = new Date();
    const pad = n => String(n).padStart(2, '0');
    return now.getFullYear() +
        pad(now.getMonth() + 1) +
        pad(now.getDate()) +
        pad(now.getHours()) +
        pad(now.getMinutes()) +
        pad(now.getSeconds());
}

function downloadJSON(data, filename) {
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function exportBoardAsHTML() {
    // Get current board data
    const boardTitle = document.getElementById('noteboardTitle').textContent || 'toolboard';
    const safeTitle = boardTitle.replace(/[^a-z0-9]/gi, '-').toLowerCase();

    const embeddedData = {
        boards: [{ id: 'default', name: boardTitle }],
        currentBoard: 'default',
        variables: variables,
        positions: positions,
        noteCustomizations: noteCustomizations,
        customNotes: customNotes,
        hiddenNotes: hiddenNotes,
        noteboardSettings: noteboardSettings
    };

    // Close modal before capturing HTML
    const modal = document.getElementById('importExportModal');
    modal.classList.remove('open');

    // Get the full HTML of the current document
    const originalHTML = document.documentElement.outerHTML;

    // Reopen modal briefly so user sees it close after download
    modal.classList.add('open');

    // Create the embedded data script that will auto-import on load
    // Note: <\/script> is escaped to prevent breaking the outer script block
    const embedScript = '<scr' + 'ipt id="embedded-board-data" type="application/json">\n' +
        JSON.stringify(embeddedData, null, 2) +
        '\n<\/scr' + 'ipt>\n' +
        '<scr' + 'ipt>\n' +
        '// Auto-import embedded board data on load\n' +
        '(function() {\n' +
        '    var dataScript = document.getElementById("embedded-board-data");\n' +
        '    if (!dataScript) return;\n' +
        '    try {\n' +
        '        var data = JSON.parse(dataScript.textContent);\n' +
        '        localStorage.setItem("financeBoards", JSON.stringify(data.boards));\n' +
        '        localStorage.setItem("financeCurrentBoard", "default");\n' +
        '        localStorage.setItem("finance_default_variables", JSON.stringify(data.variables));\n' +
        '        localStorage.setItem("finance_default_positions", JSON.stringify(data.positions));\n' +
        '        localStorage.setItem("finance_default_noteCustomizations", JSON.stringify(data.noteCustomizations));\n' +
        '        localStorage.setItem("finance_default_customNotes", JSON.stringify(data.customNotes));\n' +
        '        localStorage.setItem("finance_default_hiddenNotes", JSON.stringify(data.hiddenNotes));\n' +
        '        localStorage.setItem("finance_default_noteboardSettings", JSON.stringify(data.noteboardSettings));\n' +
        '        dataScript.remove();\n' +
        '    } catch (e) { console.error("Failed to import embedded board data:", e); }\n' +
        '})();\n' +
        '<\/scr' + 'ipt>\n';

    // Insert the embed script just before </head>
    const htmlContent = '<!DOCTYPE html>\n' + originalHTML.replace('</head>', embedScript + '</head>');

    // Download
    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${safeTitle}-${getTimestamp()}.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Close modal
    document.getElementById('importExportModal').classList.remove('open');
}

function exportBoardAsPNG() {
    // Load html2canvas dynamically if not already loaded
    if (typeof html2canvas === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
        script.onload = () => captureAndDownloadPNG();
        script.onerror = () => alert('Failed to load image export library. Please check your internet connection.');
        document.head.appendChild(script);
    } else {
        captureAndDownloadPNG();
    }
}

function captureAndDownloadPNG() {
    const boardTitle = document.getElementById('noteboardTitle').textContent || 'toolboard';
    const safeTitle = boardTitle.replace(/[^a-z0-9]/gi, '-').toLowerCase();

    // Close modal first so it's not in the screenshot
    document.getElementById('importExportModal').classList.remove('open');

    // Small delay to let the modal close
    setTimeout(() => {
        // Capture the entire page
        html2canvas(document.body, {
            backgroundColor: getComputedStyle(document.body).backgroundColor || '#1a1a2e',
            scale: 2, // Higher quality
            useCORS: true,
            logging: false,
            windowWidth: document.documentElement.scrollWidth,
            windowHeight: document.documentElement.scrollHeight
        }).then(canvas => {
            // Download the image
            const link = document.createElement('a');
            link.download = `${safeTitle}-${getTimestamp()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }).catch(err => {
            console.error('PNG export error:', err);
            alert('Failed to export as PNG. Please try again.');
        });
    }, 100);
}

function handleFileImport(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (event) => {
        document.getElementById('importTextarea').value = event.target.result;
    };
    reader.readAsText(file);
}

function importData() {
    const textarea = document.getElementById('importTextarea');
    const resultDiv = document.getElementById('importResult');

    try {
        const data = JSON.parse(textarea.value);

        if (data.type === 'notes') {
            importNotes(data);
            resultDiv.className = 'import-result success';
            resultDiv.textContent = `Successfully imported ${data.notes.length} note(s).`;
        } else if (data.type === 'boards') {
            importBoards(data);
            resultDiv.className = 'import-result success';
            resultDiv.textContent = `Successfully imported ${data.boards.length} board(s).`;
        } else {
            throw new Error('Unknown export format. Expected "notes" or "boards" type.');
        }

        // Refresh the UI
        renderNoteboard();
        populateBoardSelector();
        populateExportLists();

    } catch (err) {
        resultDiv.className = 'import-result error';
        resultDiv.textContent = `Error: ${err.message}`;
    }
}

function importNotes(data) {
    data.notes.forEach(noteData => {
        let noteId = noteData.id;

        // If it's a custom note, check for conflicts
        if (noteData.isCustom) {
            // Generate new ID if already exists
            if (customNotes.includes(noteId)) {
                noteId = 'custom-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
            }
            // Add to custom notes
            if (!customNotes.includes(noteId)) {
                customNotes.push(noteId);
            }
        }

        // Import customizations
        if (noteData.customizations && Object.keys(noteData.customizations).length > 0) {
            noteCustomizations[noteId] = { ...noteData.customizations };
        }

        // Import position (with offset if position exists)
        if (noteData.position) {
            const pos = { ...noteData.position };
            // Offset if position already taken
            if (positions[noteId]) {
                pos.x = (pos.x || 0) + 30;
                pos.y = (pos.y || 0) + 30;
            }
            pos.z = ++maxZ;
            positions[noteId] = pos;
        }
    });

    // Save changes
    saveCustomNotes(customNotes);
    saveNoteCustomizations(noteCustomizations);
    savePositions(positions);
}

function importBoards(data) {
    data.boards.forEach(boardData => {
        let boardId = boardData.id;

        // Check for conflicts and generate new ID if needed
        if (boards.some(b => b.id === boardId)) {
            boardId = 'board-' + Date.now() + '-' + Math.random().toString(36).substr(2, 5);
        }

        // Add board to list
        boards.push({
            id: boardId,
            name: boardData.name || 'Imported Board'
        });

        // Save board-specific data
        if (boardData.variables) {
            localStorage.setItem(`finance_${boardId}_variables`, JSON.stringify(boardData.variables));
        }
        if (boardData.positions) {
            localStorage.setItem(`finance_${boardId}_positions`, JSON.stringify(boardData.positions));
        }
        if (boardData.noteCustomizations) {
            localStorage.setItem(`finance_${boardId}_noteCustomizations`, JSON.stringify(boardData.noteCustomizations));
        }
        if (boardData.customNotes) {
            localStorage.setItem(`finance_${boardId}_customNotes`, JSON.stringify(boardData.customNotes));
        }
        if (boardData.hiddenNotes) {
            localStorage.setItem(`finance_${boardId}_hiddenNotes`, JSON.stringify(boardData.hiddenNotes));
        }
        if (boardData.noteboardSettings) {
            localStorage.setItem(`finance_${boardId}_noteboardSettings`, JSON.stringify(boardData.noteboardSettings));
        }
    });

    // Save updated boards list
    saveBoards(boards);
}

function setupButtons() {
    document.getElementById('addNoteBtn').onclick = addNewNote;

    // Delete board button
    document.getElementById('deleteBoardBtn').onclick = deleteCurrentBoard;

    // Board selector
    document.getElementById('boardSelector').onchange = (e) => {
        const value = e.target.value;
        if (value === '__new__') {
            createNewBoard();
        } else {
            switchToBoard(value);
        }
    };
}

// Add a new custom note - now shows feature selection modal
function addNewNote() {
    openFeatureSelectModal();
}

// Delete a custom note
function deleteNote(noteId) {
    const isCustom = customNotes.includes(noteId);
    const isBuiltIn = SECTIONS.includes(noteId);

    if (!isCustom && !isBuiltIn) return;

    const message = isCustom
        ? 'Delete this note? This cannot be undone.'
        : 'Hide this note? You can restore it later from the Import/Export menu.';

    if (confirm(message)) {
        if (isCustom) {
            // Remove from customNotes array
            customNotes = customNotes.filter(id => id !== noteId);
            saveCustomNotes(customNotes);

            // Remove customizations
            delete noteCustomizations[noteId];
            saveNoteCustomizations(noteCustomizations);

            // Remove position data
            delete positions[noteId];
            savePositions(positions);
        } else {
            // Hide built-in note
            if (!hiddenNotes.includes(noteId)) {
                hiddenNotes.push(noteId);
                saveHiddenNotes(hiddenNotes);
            }
        }

        // Remove from DOM
        const note = document.querySelector(`[data-note="${noteId}"]`);
        if (note) {
            note.remove();
        }
    }
}

// Duplicate a note
function duplicateNote(noteId) {
    const sourceCustom = noteCustomizations[noteId] || {};
    const sourcePos = positions[noteId] || { x: 50, y: 50 };

    // Generate new note ID
    const newNoteId = 'note_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

    // Add to custom notes
    customNotes.push(newNoteId);
    saveCustomNotes(customNotes);

    // Copy customizations (deep clone)
    noteCustomizations[newNoteId] = JSON.parse(JSON.stringify(sourceCustom));
    noteCustomizations[newNoteId].title = (sourceCustom.title || 'Note') + ' (Copy)';
    saveNoteCustomizations(noteCustomizations);

    // Set position offset from original
    positions[newNoteId] = {
        x: sourcePos.x + 30,
        y: sourcePos.y + 30,
        z: ++maxZ,
        width: sourcePos.width,
        height: sourcePos.height
    };
    savePositions(positions);

    // Create and add the note to DOM
    const note = createNote(newNoteId);
    if (note) {
        document.getElementById('noteboard').appendChild(note);
        // Initialize if it's a checklist or calculator
        initializeCalculators();
    }
}

// Export a note as HTML file
function exportNoteAsHtml(noteId) {
    const custom = noteCustomizations[noteId] || {};
    const content = getNoteContent(noteId);
    const title = custom.title || content.title || 'Note';
    const headerColor = custom.color || '#34495e';

    // Get the rendered content from the DOM
    const noteEl = document.querySelector(`[data-note="${noteId}"]`);
    let bodyContent = '';

    if (noteEl) {
        const contentEl = noteEl.querySelector('.note-content');
        if (contentEl) {
            bodyContent = contentEl.innerHTML;
        }
    }

    // If it's a checklist, render it nicely for export
    if (custom.checklistItems && custom.checklistItems.length > 0) {
        bodyContent = renderChecklistForExport(custom.checklistItems);
    }

    const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${escapeHtml(title)}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }
        .note {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 800px;
            margin: 0 auto;
            overflow: hidden;
        }
        .note-header {
            background: ${headerColor};
            color: white;
            padding: 15px 20px;
            font-size: 18px;
            font-weight: 600;
        }
        .note-content {
            padding: 20px;
        }
        h1, h2, h3, h4, h5, h6 { margin: 1em 0 0.5em; color: #2c3e50; }
        p { margin: 0.5em 0; }
        ul, ol { margin: 0.5em 0; padding-left: 1.5em; }
        code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-size: 0.9em; }
        pre { background: #f4f4f4; padding: 12px; border-radius: 4px; overflow-x: auto; }
        pre code { background: none; padding: 0; }
        table { border-collapse: collapse; width: 100%; margin: 1em 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background: #f8f9fa; }
        blockquote { border-left: 3px solid #3498db; margin: 1em 0; padding-left: 1em; color: #666; }
        a { color: #3498db; }
        img { max-width: 100%; height: auto; }
        .checklist { list-style: none; padding: 0; }
        .checklist-item { display: flex; align-items: flex-start; gap: 10px; padding: 8px 0; border-bottom: 1px solid #eee; }
        .checklist-item:last-child { border-bottom: none; }
        .status { width: 20px; height: 20px; border: 2px solid #ddd; border-radius: 4px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .status.completed { background: #27ae60; border-color: #27ae60; color: white; }
        .status.in_progress { background: #f39c12; border-color: #f39c12; color: white; font-size: 10px; }
        .item-text { flex: 1; }
        .item-text.completed { text-decoration: line-through; color: #999; }
        .subitems { margin-left: 30px; padding-left: 10px; border-left: 2px solid #eee; }
        .exported-date { text-align: center; color: #999; font-size: 12px; margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee; }
    </style>
</head>
<body>
    <div class="note">
        <div class="note-header">${escapeHtml(title)}</div>
        <div class="note-content">
            ${bodyContent}
            <div class="exported-date">Exported from Toolboard.me on ${new Date().toLocaleDateString()}</div>
        </div>
    </div>
</body>
</html>`;

    // Download the file
    const blob = new Blob([html], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Render checklist items for HTML export
function renderChecklistForExport(items, isSublist = false) {
    const listClass = isSublist ? 'subitems' : 'checklist';
    let html = `<ul class="${listClass}">`;

    items.forEach(item => {
        const status = item.status || 'pending';
        const statusIcon = status === 'completed' ? '✓' : (status === 'in_progress' ? '▶' : '');
        const textClass = status === 'completed' ? 'completed' : '';

        html += `<li class="checklist-item">
            <span class="status ${status}">${statusIcon}</span>
            <span class="item-text ${textClass}">${escapeHtml(item.text)}</span>
        </li>`;

        if (item.children && item.children.length > 0) {
            html += renderChecklistForExport(item.children, true);
        }
    });

    html += '</ul>';
    return html;
}

// Export a note as PNG image
async function exportNoteAsPng(noteId) {
    const noteEl = document.querySelector(`[data-note="${noteId}"]`);
    if (!noteEl) return;

    const custom = noteCustomizations[noteId] || {};
    const content = getNoteContent(noteId);
    const title = custom.title || content.title || 'Note';

    // Store original styles
    const originalPosition = noteEl.style.position;
    const originalTransform = noteEl.style.transform;
    const originalBoxShadow = noteEl.style.boxShadow;

    try {
        // Temporarily adjust note for better capture
        noteEl.style.boxShadow = '0 4px 20px rgba(0,0,0,0.15)';

        // Use html2canvas to capture the note
        const canvas = await html2canvas(noteEl, {
            backgroundColor: null,
            scale: 2, // Higher resolution
            logging: false,
            useCORS: true,
            allowTaint: true
        });

        // Restore original styles
        noteEl.style.position = originalPosition;
        noteEl.style.transform = originalTransform;
        noteEl.style.boxShadow = originalBoxShadow;

        // Convert to PNG and download
        const link = document.createElement('a');
        link.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.png`;
        link.href = canvas.toDataURL('image/png');
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

    } catch (error) {
        // Restore original styles on error
        noteEl.style.position = originalPosition;
        noteEl.style.transform = originalTransform;
        noteEl.style.boxShadow = originalBoxShadow;

        console.error('Error exporting note as PNG:', error);
        alert('Failed to export note as PNG. Please try again.');
    }
}

// Board management functions
function populateBoardSelector() {
    const selector = document.getElementById('boardSelector');
    selector.innerHTML = '';

    boards.forEach(board => {
        const option = document.createElement('option');
        option.value = board.id;
        option.textContent = board.name;
        if (board.id === currentBoardId) {
            option.selected = true;
        }
        selector.appendChild(option);
    });

    // Add "New Board" option
    const newOption = document.createElement('option');
    newOption.value = '__new__';
    newOption.textContent = '+ New Board...';
    selector.appendChild(newOption);

    // Update delete button state
    updateDeleteBoardButton();
}

function updateDeleteBoardButton() {
    const deleteBtn = document.getElementById('deleteBoardBtn');
    // Disable delete if only one board exists
    deleteBtn.disabled = boards.length <= 1;
}

function createNewBoard() {
    const name = prompt('Enter name for new board:', 'New Board');
    if (!name) {
        // Reset selector to current board
        document.getElementById('boardSelector').value = currentBoardId;
        return;
    }

    const newBoardId = 'board-' + Date.now();
    boards.push({ id: newBoardId, name: name });
    saveBoards(boards);

    // Initialize noteboard settings with the provided name
    localStorage.setItem(`finance_${newBoardId}_noteboardSettings`, JSON.stringify({ title: name, color: '#2c3e50' }));

    // Switch to the new board
    switchToBoard(newBoardId);
}

function switchToBoard(boardId) {
    if (boardId === currentBoardId) return;

    currentBoardId = boardId;
    setCurrentBoardId(boardId);

    // Reload all board-specific data
    variables = loadVariables();
    positions = loadPositions();
    noteCustomizations = loadNoteCustomizations();
    customNotes = loadCustomNotes();
    hiddenNotes = loadHiddenNotes();
    noteboardSettings = loadNoteboardSettings();
    maxZ = Math.max(...Object.values(positions).map(p => p.z || 1), 1);

    // Update UI
    populateBoardSelector();
    applyNoteboardSettings();
    renderNoteboard();
}

function deleteCurrentBoard() {
    if (boards.length <= 1) {
        alert('Cannot delete the last board.');
        return;
    }

    const currentBoard = boards.find(b => b.id === currentBoardId);
    if (!confirm(`Delete board "${currentBoard.name}"? This cannot be undone.`)) {
        return;
    }

    // Remove board-specific data from localStorage
    localStorage.removeItem(boardKey('variables'));
    localStorage.removeItem(boardKey('positions'));
    localStorage.removeItem(boardKey('noteCustomizations'));
    localStorage.removeItem(boardKey('customNotes'));
    localStorage.removeItem(boardKey('hiddenNotes'));
    localStorage.removeItem(boardKey('noteboardSettings'));

    // Remove from boards array
    boards = boards.filter(b => b.id !== currentBoardId);
    saveBoards(boards);

    // Switch to first available board
    switchToBoard(boards[0].id);
}

function renameBoardInSelector() {
    const currentBoard = boards.find(b => b.id === currentBoardId);
    if (currentBoard && noteboardSettings.title !== currentBoard.name) {
        currentBoard.name = noteboardSettings.title;
        saveBoards(boards);
        populateBoardSelector();
    }
}

// Initialize on load
document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
